<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux操作系统</title>
      <link href="/2021/10/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/10/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第40周总结</title>
      <link href="/2021/09/27/%E6%80%BB%E7%BB%93/%E7%AC%AC40%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2021/09/27/%E6%80%BB%E7%BB%93/%E7%AC%AC40%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>继续保持</p><a id="more"></a><h1 id="9月27日"><a href="#9月27日" class="headerlink" title="9月27日"></a>9月27日</h1><p>星期一</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>volatile</p><p>零拷贝：到底几次IO?</p><p>普通读取文件IO操作</p><ul><li>方案一：CPU完全参与数据的搬运过程：发起IO请求，磁盘将数据放入磁盘缓冲区，CPU数据把磁盘控制缓冲区数据Copy到Page Cache，然后再Copy到用户缓冲区。</li><li>方案二：DMA搬运数据：IO请求，磁盘缓冲区的数据准备好后，DMA去把磁盘缓冲区的数据读到内核缓冲区，再拷贝到用户缓冲区。</li></ul><h1 id="9月29日"><a href="#9月29日" class="headerlink" title="9月29日"></a>9月29日</h1><p>星期三</p><h2 id="技术-1"><a href="#技术-1" class="headerlink" title="技术"></a>技术</h2><p>看几个概念：音视频传输方面，webrtc，RFC Design，怎么实现udp可靠传输，http音视频推送，rtm，ffmpeg，实时音视频传输</p><p>高带宽、高并发、低时延</p><p>沙漠有丰富的太阳能、雅鲁藏布江有丰富的水能。现在东北停电是怎么回事，国内火热能，地热能，水，风的占比是什么样的？</p><p>信息的编解码似乎是一种通用的手段，可以看作是做一种特征压缩或者是特征提取。但算法千差万别。深度学习的编码容易，但很难再解出原来的信息，音视频包括多种网络请求，要编码，同时希望接收到信息方可以解码出原来的信息。</p><h2 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h2><h2 id="o2o"><a href="#o2o" class="headerlink" title="o2o"></a>o2o</h2><p>线下零售（物美）到现在线上零售淘宝，pdd，又到新零售（我理解是线上线下结合）</p><p>o2o从2010年开始，到现在发展了10年，接下来会往什么方向发展。</p><p>美团和这样的新零售又有什么相通之处？</p><h3 id="比亚迪"><a href="#比亚迪" class="headerlink" title="比亚迪"></a>比亚迪</h3><p>刀片电池</p><p>燃油车、新能源汽车</p><p>云巴，云轨道</p><p>SNS等</p><h1 id="9月30日"><a href="#9月30日" class="headerlink" title="9月30日"></a>9月30日</h1><p>星期四</p><h2 id="技术-2"><a href="#技术-2" class="headerlink" title="技术"></a>技术</h2><p>解答音视频传输协议的问题</p><p>H.323</p><p><img src="https://pic2.zhimg.com/80/v2-e499cdbadeec40c217803a7d130204a6_720w.jpg?source=1940ef5c" alt="img"></p><h2 id="领域-1"><a href="#领域-1" class="headerlink" title="领域"></a>领域</h2><p>芯片</p><ul><li><p>中国3k加芯片公司，最后能存活下来的可能只有80%</p></li><li><p>产业链</p><ul><li>上游：IP、EDA、芯片设计</li><li>下游：芯片制造、封测</li></ul></li><li><p>芯片分类</p><ul><li>功能：CPU</li><li>存储：闪存（半导体芯片，硬盘是靠磁介质）</li></ul></li><li><p>产业</p><ul><li>设计（难，中国多是中低端）</li><li>制作<ul><li>沙子（$SiO_2$​​) 提取出 Si，涂光刻胶，（紫外线）进行光刻，腐蚀（形成凹槽），掺杂（硼或磷），洗好后，连电路。</li></ul></li><li>封装（制作出来后进行包装）</li></ul></li></ul><p>台积电制造麒麟（KIRIN）9000 芯片 （安卓手机）5nm</p><p>香农证明任何能够表达开和关的元器件，都可以表达任意逻辑。</p><p>14nm，7nm，5nm。摩尔定理，</p><p>面积太小会有量子隧穿效应，环绕栅极。</p><p>光刻机：荷兰ASML</p><p>通用型芯片、专用芯片（TPU，GPU，NPU1）</p><h3 id="期货"><a href="#期货" class="headerlink" title="期货"></a>期货</h3><p>远期合约（先付一笔钱签一份合约，如买房子）</p><p>作用：套期保值（双方其实都有需求）</p><p>例子：</p><ul><li>荷兰郁金香、江户幕府稻米</li></ul><p>问题：</p><ul><li>毁约、质量、交易（因为某些原因，不能按原有方式交易）</li></ul><p>标准期货合约</p><ul><li>1865年，芝加哥：质量、数量、时间、地点、场内交易（在交易所卖掉）</li></ul><p>投机交易</p><p>合约价格 = 单价 * 规模  </p><p>开仓（卖方（空方）卖给买方（多方））、平仓 （买方交钱给卖方）</p><p>和股票区别</p><ul><li>保证金交易，会出现平仓</li></ul><p>到期日交割</p><ul><li>平仓、移仓换月（续约）、交割（实物、政金）</li><li>多方：以某个价格获得物品</li><li>投资者：可能倾家荡产</li></ul><p>经济泡沫</p><ul><li><p>郁金香狂热</p><ul><li><p>背景</p><ul><li><p>荷-西战争：政治独立</p></li><li><p>东印度公司：经济富有</p></li><li><p>郁金香  中亚：土耳其-&gt;西欧（精神需要）</p></li><li><p>郁金香  种子5-7年，球茎1年</p></li><li><p>1634年  行业协会    “酒钱”， 1636年 期货 1637年4月  1637年1月 奥古斯都 6290 盾  1637年2月   价格下跌 0.1盾   1637年4月 3.5%</p></li><li><p>类似事件：长春君子兰</p><ul><li>非洲-&gt;日本-&gt;中国溥仪-&gt;长春民间<ul><li>1982年 限价：200元  1982年  义展  17000元 1984年 窗台经济  市花 1985年 皇冠 14万元  1985年  人民日报</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>中国有哪些山脉？</p><p>希腊为啥诞生手工业？</p><h1 id="10月1日"><a href="#10月1日" class="headerlink" title="10月1日"></a>10月1日</h1><p>星期五</p><h2 id="技术-3"><a href="#技术-3" class="headerlink" title="技术"></a>技术</h2><h3 id="网络IO演变过程及网络模型介绍"><a href="#网络IO演变过程及网络模型介绍" class="headerlink" title="网络IO演变过程及网络模型介绍"></a>网络IO演变过程及网络模型介绍</h3><ul><li><p>网络IO演变过程</p><ul><li>整体步骤：创建socketfd，bind将fd和地址绑定，listen fd，accept fd。read、write。</li></ul><p><img src="/2021/09/27/%E6%80%BB%E7%BB%93/%E7%AC%AC40%E5%91%A8%E6%80%BB%E7%BB%93/C:%5CUsers%5Clighteningzhang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211001110036857.png" alt="image-20211001110036857"></p><ul><li><p>阻塞IO</p><ul><li>一个client会消耗一个线程来处理</li><li>大量线程会造成上下文切换影响性能</li></ul></li><li><p>非阻塞IO</p><ul><li>设置<ul><li>SOCK_NONBLOCK可以设置socket为非阻塞</li><li>fcntl将fd设置为非阻塞</li></ul></li><li>与阻塞IO对比<ul><li>内核数据未就绪时，非阻塞IO直接返回EWOULDBLOCK错误。阻塞会一直在阻塞状态，直到数据就绪并拷贝到用户态缓存。</li><li>非阻塞可以一个线程管理多个client连接，缺点：不断轮询内核，数据是否就绪，涉及很多无效频繁的系统调用（？）。</li></ul></li></ul></li><li><p>IO复用</p><p><img src="/2021/09/27/%E6%80%BB%E7%BB%93/%E7%AC%AC40%E5%91%A8%E6%80%BB%E7%BB%93/C:%5CUsers%5Clighteningzhang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211001110739185.png" alt="image-20211001110739185"></p><ul><li>解决非阻塞IO不断主动询问的问题。</li><li>一个观点：IO多路复用实际是复用系统调用</li><li>select、poll<ul><li>问题：全量拷贝fd到内核态，事件就绪后，全量拷贝fd到用户态，只告诉用户有事件就绪（用户不知道哪些事件，要自己去轮询）</li></ul></li><li>epoll<ul><li>ET：事件就绪就触发、LT：事件就绪或就绪事件没处理完</li></ul></li></ul></li><li><p>信号IO</p><ul><li>信号机制sigaction</li></ul></li><li><p>异步IO</p><ul><li>观点：同步用户自己去拷贝，异步拷贝好给用户</li></ul><p><img src="/2021/09/27/%E6%80%BB%E7%BB%93/%E7%AC%AC40%E5%91%A8%E6%80%BB%E7%BB%93/C:%5CUsers%5Clighteningzhang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211001114335116.png" alt="image-20211001114335116"></p></li><li><p>IO模式</p><ul><li>Thread-based（阻塞IO）</li></ul><p><img src="/2021/09/27/%E6%80%BB%E7%BB%93/%E7%AC%AC40%E5%91%A8%E6%80%BB%E7%BB%93/C:%5CUsers%5Clighteningzhang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211001114924477.png" alt="image-20211001114924477"></p></li></ul></li></ul><ul><li>single-Reactor单线程网络模型</li></ul><p><img src="/2021/09/27/%E6%80%BB%E7%BB%93/%E7%AC%AC40%E5%91%A8%E6%80%BB%E7%BB%93/C:%5CUsers%5Clighteningzhang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211001115012437.png" alt="image-20211001115012437"></p><ul><li><p>single-reactor线程池模型</p><ul><li>百万高并发也无法承受</li></ul><p><img src="/2021/09/27/%E6%80%BB%E7%BB%93/%E7%AC%AC40%E5%91%A8%E6%80%BB%E7%BB%93/C:%5CUsers%5Clighteningzhang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211001115218616.png" alt="image-20211001115218616"></p></li><li><p>multi-reactor多线程模型</p></li></ul><p><img src="/2021/09/27/%E6%80%BB%E7%BB%93/%E7%AC%AC40%E5%91%A8%E6%80%BB%E7%BB%93/C:%5CUsers%5Clighteningzhang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211001115319163.png" alt="image-20211001115319163"></p><p>Redis</p><ul><li>简介</li><li>数据结构</li><li>持久化</li></ul><p>Mysql</p><p>Join buffer?</p><p>云原生</p><p><a href="https://mp.weixin.qq.com/s/yX0hgIOLuaKsAcrWfOfcUQ" target="_blank" rel="noopener">科普文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第39周总结</title>
      <link href="/2021/09/22/%E6%80%BB%E7%BB%93/%E7%AC%AC39%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2021/09/22/%E6%80%BB%E7%BB%93/%E7%AC%AC39%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>9-22开始，距离上一次记录已经过去30多周了</p><a id="more"></a><h1 id="9月22日"><a href="#9月22日" class="headerlink" title="9月22日"></a>9月22日</h1><p>星期三</p><p>画了个初步的图，认识了思维导图的重要性。分清主次，知识分层次很重要。实验记录和实验代码注释及路径清晰也很重要。</p><p>对HTTP3（QUIC）的报文结构也更有了了解，HTTP3中多个Stream可以用一条连接，Stream可以拆分为多个Packet，Packet又可以拆为多个Frame。但因为没有实际编码和使用，还是不太深。</p><p>专注度还有待加强，及时性的消息不用太关注。分时间段的来进行学习以及做毕设。</p><p><img src="/2021/09/22/%E6%80%BB%E7%BB%93/%E7%AC%AC39%E5%91%A8%E6%80%BB%E7%BB%93/image-20210922205710373.png" alt="image-20210922205710373"></p><h1 id="9月23日"><a href="#9月23日" class="headerlink" title="9月23日"></a>9月23日</h1><p>星期四</p><p>面试了华为消费者BG。发现知识缺陷：HTTPS加密算法、微服务、线程池</p><h1 id="9月25日"><a href="#9月25日" class="headerlink" title="9月25日"></a>9月25日</h1><p>星期六</p><p>最近有点颓，也在胡思乱想。</p><p>考虑知识分块的事。自己的无知其实对未来也有很大的影响。人文社科与科学技术。我做的大部分其实属于科学技术里的计算机技术这块。但其实很多东西没有去深挖，一个是相通性没找到太好的点，导致兴趣度不高。因此，当下需要考虑的是一个博，也就是DFS感觉走不下去了就要考虑一下BFS了。</p><h1 id="9月26日"><a href="#9月26日" class="headerlink" title="9月26日"></a>9月26日</h1><p>星期天</p><p>这周太颓了。基本没干啥正事，但也感觉状态没调节好。看了一些大佬的演讲和采访。觉得王小川是真的厉害，能把很多东西浅显讲出来，同时他是懂细节的。比如区块链这个概念，他分了三个层次来讲：技术，经济，政治。这个视角很多技术人是没有的，这给我的启发是，一个人不能给自己的定位太死，比如一个程序员就定位自己只懂程序，那除非你一项做的超过其他人几个level，否则必然劣势会彰显无遗。看了马化腾的演讲，也明白了对于局势变化，人也要快速进行变化。微信也是就此而诞生的。移动互联网时代的到来，抓住他的就是机会，而没跟上的基本也就被淘汰了。</p><p>下周争取能多调整下。试下每天晚上去跑步，看能坚持多久。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些疑问</title>
      <link href="/2021/09/22/%E6%97%A5%E5%B8%B8%E5%9B%B0%E6%83%91/%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE/"/>
      <url>/2021/09/22/%E6%97%A5%E5%B8%B8%E5%9B%B0%E6%83%91/%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>愤青的日常困惑</p><a id="more"></a><h1 id="需要了解的技术"><a href="#需要了解的技术" class="headerlink" title="需要了解的技术"></a>需要了解的技术</h1><p>Netty</p><h1 id="关于互联网产品"><a href="#关于互联网产品" class="headerlink" title="关于互联网产品"></a>关于互联网产品</h1><ul><li>谷歌这个检索系统是怎么做出来的？如何实现在海量数据中对内容的精确匹配？<ul><li>这里的精确匹配一个是指意思的精确匹配，另外一个是指关键字怎么精确匹配的（既要分词，还要海量文本匹配，还能秒级返回）？</li><li>一个想法是把每个文档中的关键字全部拆出来。每个文档按关键字的bit位组成。</li></ul></li><li>直播这个技术是怎么做到的（实时音视频传输）</li><li>区块链怎么实现的？（技术、经济、政治）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常困惑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线上资源</title>
      <link href="/2021/09/20/%E8%B5%84%E6%BA%90/%E7%BA%BF%E4%B8%8A%E8%B5%84%E6%BA%90/"/>
      <url>/2021/09/20/%E8%B5%84%E6%BA%90/%E7%BA%BF%E4%B8%8A%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>一些线上的资源和观看感受</p><a id="more"></a><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p><a href="https://www.youtube.com/watch?v=_8-ht2AKyH4" target="_blank" rel="noopener">youtube 内存分段部分，封面图片看着还可以</a></p><p><a href="https://www.youtube.com/watch?v=EiWsPd6JDoo" target="_blank" rel="noopener">youtube kafka概要讲解</a></p><p><a href="http://www.4k8k.xyz/article/u013310119/51842996" target="_blank" rel="noopener">李运华: 程序员如何在技术上提升自己</a></p><ul><li>链式学习：从一个点发散到面</li><li>闭环学习：全链路学习</li></ul><p><a href="https://www.bilibili.com/video/BV1SU4y1W7oE?from=search&seid=8464071150512328208&spm_id_from=333.337.0.0" target="_blank" rel="noopener">李运华: 助我成长的那些架构项目</a></p><ul><li>用户关系网络系统<ul><li>业务需求</li><li>优化算法</li></ul></li><li>运维自动化平台<ul><li>义工</li><li>成事能力和技术能力一样重要</li></ul></li><li>阿里游戏异地多活：一战成名<ul><li>面向业务的立体化高可用架构设计</li><li>3分钟发现问题，5分钟恢复</li><li>异地多活</li><li>技术本质理解比死记硬背更关键</li><li>CRC32</li></ul></li></ul><p><a href="https://www.bilibili.com/video/BV12T4y1w7Gu?p=10" target="_blank" rel="noopener">陶辉 : 搞懂 Nginx 核心工作原理</a></p><ul><li>路由器中的最后一公里问题</li></ul><p><a href="https://www.bilibili.com/video/BV1hk4y1m7KE?from=search&seid=11132047857723194079&spm_id_from=333.337.0.0" target="_blank" rel="noopener">陶辉 : NGINX支持QUIC/HTTP3的实现路径和实践思考</a></p><ul><li><p>HTTP1</p><ul><li>请求<ul><li>start-line(request-line / status-line)</li><li>header-field</li><li>message-body</li></ul></li><li>语义<ul><li>(Client Request / Server Response机制)</li><li>Header + body编码协议</li></ul></li><li>问题<ul><li>无状态（会放大编码效率低的问题）</li><li>编码效率低</li><li>慢启动（慢慢打起来流量，带宽打起来比较慢）</li><li>建连接（最后一公里问题）</li><li>异步编程开发效率（没懂为什么同步比异步更好）</li><li>长连接中止请求代价高（终止连接需要重新建）</li><li>不支持服务器推送(接受服务器消息)</li><li>HTTP不支持流控</li></ul></li></ul></li><li><p>HTTP2</p><ul><li>特性<ul><li>多路复用<ul><li>Stream级流控</li><li>带权重优先级</li><li>Reset置位（可以复用一个连接）</li></ul></li><li>HPACK头部编码（动态表）</li><li>服务器消息推送</li></ul></li><li>问题<ul><li>队头阻塞（队头出问题影响后面的frame）</li><li>建连接（两次握手：传输层和TLS）</li></ul></li></ul></li><li><p>HTTP3</p><ul><li>标准</li></ul><p><img src="/2021/09/20/%E8%B5%84%E6%BA%90/%E7%BA%BF%E4%B8%8A%E8%B5%84%E6%BA%90/image-20210921182209386.png" alt="image-20210921182209386"></p></li></ul><ul><li>连接迁移<ul><li>固定的连接ID</li><li>连接变了：PATH_CHALLENGE Frame<ul><li>PMTU验证</li><li>拥塞控制清零</li></ul></li></ul></li><li>概念<ul><li>Packet<ul><li>Long Packet Header/Short Packet Header</li></ul></li><li>QUIC Frame<ul><li>不可跨越Packet</li><li>Stream有序字节流<ul><li>双向Stream</li><li>单向Stream<ul><li>QPACK动态表、服务器推送</li></ul></li></ul></li><li>Packet 源连接ID / 目的连接ID</li><li>如何避免恶意FLOOD（Retry）</li></ul></li><li>HTTP3 Frame<ul><li>可跨越多个Packet</li></ul></li><li>Message</li></ul></li><li>补充<ul><li>Frame仍是最小单元（类比HTTP2），多个Frame组合成为Packet，多个Packet可能在一次UDP传输中发出。多个Packet组成Stream</li><li>Stream之间相互独立，某个流出现丢包并不影响其他流。（避免队头阻塞）</li></ul></li></ul><h1 id="线上课程"><a href="#线上课程" class="headerlink" title="线上课程"></a>线上课程</h1><h2 id="直播课程"><a href="#直播课程" class="headerlink" title="直播课程"></a>直播课程</h2><p>Dubbo</p><ul><li>三位一体：商业化、开源、自研</li><li>云原生时代的微服务发展<ul><li>K8S资源调度，Mesh化被逐渐接受</li><li>底层设施易变，云上微服务多元</li><li>访问爆炸性增长</li></ul></li></ul><h2 id="历史地理"><a href="#历史地理" class="headerlink" title="历史地理"></a>历史地理</h2><h3 id="纪录片"><a href="#纪录片" class="headerlink" title="纪录片"></a>纪录片</h3><p>​    纪录片《世界历史》</p><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><p>《希腊人：历史、文化和社会》</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><a href="https://blog.csdn.net/yunhua_lee" target="_blank" rel="noopener">李运华大佬博客</a></p><p><a href="https://www.bugstack.cn/" target="_blank" rel="noopener">据说是京东架构师，JAVA强相关</a></p><p><a href="https://blog.codingnow.com/" target="_blank" rel="noopener">游戏开发大佬云风，里面很多游戏开发的Idea</a></p><p><a href="https://www.oilshell.org/blog/" target="_blank" rel="noopener">Andy Chu 很多shell相关</a></p><p><a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">设计模式博客，看着卡通挺不错</a></p><p><a href="https://tech.meituan.com/archives" target="_blank" rel="noopener">美团的博客，比较杂</a></p><h1 id="Github-repo"><a href="#Github-repo" class="headerlink" title="Github repo"></a>Github repo</h1><p><a href="https://github.com/idealvin/co" target="_blank" rel="noopener">RPC框架源码</a></p><p><a href="https://blog.zhuangty.com/" target="_blank" rel="noopener">庄天翼大佬Blog，里面有数据库的前沿分享</a></p><p><a href="https://andremouche.github.io/categories.html" target="_blank" rel="noopener">程序媛里面有一些云和存储的分享</a></p><h1 id="行业大佬"><a href="#行业大佬" class="headerlink" title="行业大佬"></a>行业大佬</h1><p>开源kafka</p><p>jay kreps：Confluent公司CEO</p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设提纲和计划</title>
      <link href="/2021/09/17/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E8%AE%BE%E6%8F%90%E7%BA%B2%E5%92%8C%E8%AE%A1%E5%88%92/"/>
      <url>/2021/09/17/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E8%AE%BE%E6%8F%90%E7%BA%B2%E5%92%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>毕业设计</p><a id="more"></a><p>需要注意的问题：</p><ul><li><p>实验</p><ul><li>先写方案再做</li><li>实验记录和文件管理很重要</li><li>画图色系很重要，要会调色</li></ul></li></ul><p>  方案图</p><p>  <img src="/2021/09/17/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E8%AE%BE%E6%8F%90%E7%BA%B2%E5%92%8C%E8%AE%A1%E5%88%92/image-20210922205508806.png" alt="image-20210922205508806"></p><p>原来论文的实验</p><ul><li>在服务器上的路径：</li></ul><p>异常检测实验</p><ul><li><p>数据预处理</p><ul><li>属性异常点</li><li>结构异常点</li></ul></li><li><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2></li></ul><p>推荐系统实验</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未一次性解出</title>
      <link href="/2021/09/17/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98/%E6%9C%AA%E4%B8%80%E6%AC%A1%E6%80%A7%E8%A7%A3%E5%87%BA/"/>
      <url>/2021/09/17/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98/%E6%9C%AA%E4%B8%80%E6%AC%A1%E6%80%A7%E8%A7%A3%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>记录下未做出的题</p><a id="more"></a><p>301.删除的无效括号</p><p>觉得难点：先要判断需要删除的最少数量（dfs），然后再考虑删这个数量的括号。这样似乎能做，但时间复杂度比较高。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣做题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>已刷题总结</title>
      <link href="/2021/09/17/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98/%E5%B7%B2%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2021/09/17/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98/%E5%B7%B2%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 力扣做题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2021/09/14/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2021/09/14/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这类问题本质都是状态转移，背包问题分为：</p><ul><li>01背包</li><li>完全背包</li><li></li></ul><a id="more"></a><p>01背包、分组背包、完全背包及多重背包是一类问题，本质就是状态覆盖。</p><p>多重背包和分组背包是一类问题</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间管理</title>
      <link href="/2021/09/10/%E8%AE%A1%E5%88%92/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
      <url>/2021/09/10/%E8%AE%A1%E5%88%92/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>记录自己的一些计划</p><a id="more"></a><p>2021-09-10</p><p>早上10点至12点           拟八股提纲和重点问题</p><p>下午2点至下午3点30   刷题</p><p>下午3点30至下午6点   整理重点问题</p><p>晚上6点30                      完成中期报告（预计2小时）</p><p>2021-09-14</p><p><del>复习一下背包问题</del></p><p>复习一下QUIC</p><p>学一下文件系统</p><p>2021-09-22</p><p>看一下毕设实验怎么做，拟一下提纲和方案</p>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秋招最后准备</title>
      <link href="/2021/09/10/%E9%9D%A2%E8%AF%95/%E7%A7%8B%E6%8B%9B%E6%9C%80%E5%90%8E%E5%87%86%E5%A4%87/"/>
      <url>/2021/09/10/%E9%9D%A2%E8%AF%95/%E7%A7%8B%E6%8B%9B%E6%9C%80%E5%90%8E%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>总拟下提纲，面试不能解决根本问题，还是需要平时的日积月累。</p><a id="more"></a><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>操作系统是利用有限的资源（内存，cpu），调度各种各样的任务。</p><p>进程、线程与协程</p><ul><li>进程 线程 协程的切换</li><li>进程线程的通信方式、协程怎么调度</li></ul><p>父子进程</p><ul><li>孤儿进程、僵尸进程<ul><li>孤儿进程：父进程退出，子进程还在运行，init会接管这个子进程（循环调用wait）    </li><li>僵尸：fork创建子进程，如果子进程退出，父进程没有wait或者waitpid，进程描述符仍保留在系统中。</li></ul></li><li>fork子进程</li></ul><p>锁</p><ul><li>互斥、自旋</li></ul><p>虚拟地址空间和虚拟内存</p><p>​            分段和分页，怎么结合的？</p><ul><li>分段：内核、栈、堆、BSS（未初始化静态变量）、Data（已初始化全局数据）、Text（代码段）</li><li>分页：分段是mm_struct结构体中的存放方式，是虚拟地址，分页是将虚拟地址映射到物理地址</li><li>mmap：mmap是将文件fd映射到内存中（此时还是虚拟地址），mmu才是完成虚拟地址到物理地址的映射</li><li>mmu</li></ul><p>文件系统（inode和文件名怎么对应的？是一级索引还是二级）</p><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><p>虚拟地址空间</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>应用层</p><p>http和https</p><ul><li>tls1.2 / tls1.3</li><li>http1.0, http1.1, http2.0, http3.0</li></ul><p>传输层</p><ul><li>udp / tcp</li></ul><p>IP层</p><ul><li>Ping</li><li>路由器怎么传输的</li></ul><p>网络收发包</p><ul><li>poll epoll select</li><li>socket</li></ul><h2 id="经典问题-1"><a href="#经典问题-1" class="headerlink" title="经典问题"></a>经典问题</h2><p>浏览器输入一个网址到看到结果的整个过程</p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>stl</p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>分布式锁</p><p>分布式存储</p><p>raft、paxos</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统学习</title>
      <link href="/2021/04/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/04/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Paper-Reading"><a href="#Paper-Reading" class="headerlink" title="Paper Reading"></a>Paper Reading</h1><h2 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h2><p>对client支持 open, write（追加写）, close, read 等操作。</p><p>每个文件和chunk server的对应关系存储在master中</p><ol><li>分了两层，master管理chunk server</li><li>master上存了文件和chunk server的对应关系(动态更新)</li></ol><p><img src="/2021/04/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/image-20210403165415234.png" alt="image-20210403165415234"></p><h2 id="Big-Table"><a href="#Big-Table" class="headerlink" title="Big Table"></a>Big Table</h2>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.824</title>
      <link href="/2021/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/6.824/"/>
      <url>/2021/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/6.824/</url>
      
        <content type="html"><![CDATA[<p><a href="http://nil.csail.mit.edu/6.824/2020/schedule.html" target="_blank" rel="noopener">课程链接</a></p><p><a href="https://youtu.be/cQP8WApzIQQ?t=292" target="_blank" rel="noopener">上次观看到了</a></p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="分布式要解决的问题："><a href="#分布式要解决的问题：" class="headerlink" title="分布式要解决的问题："></a>分布式要解决的问题：</h2><p>Parallelism</p><p>Fault tolerance</p><p>Physical</p><p>Scecurity / isolated</p><h2 id="挑战："><a href="#挑战：" class="headerlink" title="挑战："></a>挑战：</h2><p>Concurrency</p><p>Partial failure</p><p>Performance：scalability</p><p><strong>Infrastructure abstraction</strong></p><p>Storage</p><p>Communications</p><p>Computation</p><h1 id="Big-Storage"><a href="#Big-Storage" class="headerlink" title="Big Storage"></a>Big Storage</h1><p>Performance </p><p>Tolerance-&gt;Replication</p><p>Inconsistency</p><p>Consistency </p><p>Strong Consistency</p><h1 id="Q"><a href="#Q" class="headerlink" title="Q?"></a>Q?</h1><p>event-driven 和 multi-thread的区别？</p>]]></content>
      
      
      <categories>
          
          <category> 计算机课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.null</title>
      <link href="/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/6.null/"/>
      <url>/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/6.null/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Linux-命令行"><a href="#Linux-命令行" class="headerlink" title="Linux 命令行"></a>Linux 命令行</h1><p>tail 打印最后n行</p><p>打印最后一个：ls -l / | tail -n1</p><p>find -name / -iname 区别</p><p>tee </p><p>$_</p><p>!!</p><p>$? //啥作用</p><p>find . -name ‘*.py’  -exec rm {} ;</p><p>echo $? (查看errono)</p><p>history 查看历史</p>]]></content>
      
      
      <categories>
          
          <category> 计算机课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象存储</title>
      <link href="/2021/03/19/%E5%AD%98%E5%82%A8/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"/>
      <url>/2021/03/19/%E5%AD%98%E5%82%A8/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>知乎问题的经验：<a href="https://www.zhihu.com/question/43687427" target="_blank" rel="noopener">https://www.zhihu.com/question/43687427</a></p><p>《大话存储II》</p><p>《存储技术原理分析-基于linux2.6内核源代码》</p><p>FAST会议</p><p>Ceph</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里笔试</title>
      <link href="/2021/03/09/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%E7%AC%94%E8%AF%95/"/>
      <url>/2021/03/09/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>记录阿里的笔试题目（轻虐 = =）</p><a id="more"></a><h2 id="3-6-两道hard"><a href="#3-6-两道hard" class="headerlink" title="3.6 两道hard"></a>3.6 两道hard</h2><p>第一道是线性动态规划，设计好状态转移方程就问题不大，第二道是最短路径，难点在构造最短路上。（数据范围需要使用一些trick合并）</p><p>阿里3.6笔试第一题 <a href="https://paste.ubuntu.com/p/frHYvk95zJ/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/frHYvk95zJ/</a></p><p>阿里3.6笔试第二题 <a href="https://paste.ubuntu.com/p/KPK2gHc4dW/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/KPK2gHc4dW/</a></p><h2 id="3-8-一道easy，一道hard"><a href="#3-8-一道easy，一道hard" class="headerlink" title="3.8 一道easy，一道hard"></a>3.8 一道easy，一道hard</h2><p>第一题需要注意一下边界，第二题是稍难的背包，主要的难点在给背包的容量设置一个上限，并且大于上限的更新均在上限处。</p><p>阿里3.8笔试第一题 <a href="https://paste.ubuntu.com/p/H2d6JRDPxD/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/H2d6JRDPxD/</a></p><p>阿里3.8笔试第二题 <a href="https://paste.ubuntu.com/p/7ZqxzK2572/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/7ZqxzK2572/</a></p><h2 id="3-11阿里云一面"><a href="#3-11阿里云一面" class="headerlink" title="3.11阿里云一面"></a>3.11阿里云一面</h2><p>写一道简单dfs，竟然没用dfs的方法写… T __ T … lc 386 (人无)，写了半个小时，而且最后给的答案是错的…</p><p>今早改对了 <a href="https://paste.ubuntu.com/p/y7pVdB4ZPg/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/y7pVdB4ZPg/</a></p><p>简洁的解法 <a href="https://paste.ubuntu.com/p/x76RtJKp7z/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/x76RtJKp7z/</a></p><p>上次面蚂蚁机器智能也遇到了一样的问题…本来不是一个复杂的东西，就是脑子需要转一下….下次没思路就瞎写一通…</p><p>另外关于sizeof 和 strlen 这两个函数，发现搞混了。char* p = “12345”, strlen遇到’\0’结束，而sizeof是返回char* 这个数据类型的大小，比如sizeof(p) == 4, strlen(p) = 5。</p><p>这次面试的算法题和上次蚂蚁机器智能的算法题都没写好，一个是dfs，一个是dp，都是从简单题拓展的，最后答案的形式也不复杂…但都没往答案的那方面去想，提醒我要好好总结基础题型及其派生类。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库总结</title>
      <link href="/2021/03/08/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/"/>
      <url>/2021/03/08/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li>事务</li><li>索引</li><li>查询优化</li><li>并发控制</li></ul><a id="more"></a><p>事务隔离及实现方式</p><ol><li>读未提交</li></ol><ol start="2"><li><p>读提交</p></li><li><p>可重复读</p></li><li><p>可序列化</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补题</title>
      <link href="/2021/02/27/%E5%85%B6%E4%BB%96/%E8%A1%A5%E9%A2%98/"/>
      <url>/2021/02/27/%E5%85%B6%E4%BB%96/%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>需要补的知识和题，以及要查的一些问题</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>TinyWeb为什么setsocketpair一端要setnonblock（感觉应该没区别）</li><li>自己猜测的一个结论：epoll_wait(efd,  events,  MX_EVENTS_NUM, -1) 这里等待的events 必然是小于等于efd上的节点数目。</li><li><del>为什么TinyWebServer里，工作线程在发现是连接请求的时候要用while(1) {accept}，而不是直接一次accept。如果listenfd在同一时间应该只会监听一个文件描述符？</del> 这里设置了listenfd为non block，因此accept不会阻塞，在没有连接到来的情况下会返回-1。</li><li>writev，读写缓冲区的作用是啥？</li><li>学一下编译原理，解这个问题：为啥在recv后面放个sleep，就可以把buffer读全，不放就会再回到recv读。<a href="https://www.codenong.com/cs106961442/" target="_blank" rel="noopener">代码在这儿</a></li></ul><h1 id="补题"><a href="#补题" class="headerlink" title="补题"></a>补题</h1><ol><li><p>leetcode:</p><p><del>递归395</del>(每次判定左右)</p><p>回文串<del>516</del>(注意下顺序), <del>1771</del></p><p>周赛第四题车队2: 1776(用类似链表的方法)</p><p>lc 334 以O(n)是否存在i &lt; j &lt; k同时满足nums[i] &lt; nums[j] &lt; nums[k] (用if实现3指针)</p></li></ol><h1 id="学到的"><a href="#学到的" class="headerlink" title="学到的"></a>学到的</h1><ul><li>EPOLLONESHOT 的作用：保证文件描述符上的事件只会被触发一次，触发一次后，这个fd上的事件就被清除了，避免多个线程同时对一个fd操作。一般在处理完后还要再重置fd上的事件。</li></ul><h1 id="要学的"><a href="#要学的" class="headerlink" title="要学的"></a>要学的</h1><ol><li>Dockerfile</li><li>makefile</li></ol>]]></content>
      
      
      <categories>
          
          <category> Req </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 补 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>server</title>
      <link href="/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/server/"/>
      <url>/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/server/</url>
      
        <content type="html"><![CDATA[<p>网络编程</p><a id="more"></a><h1 id="已有储备"><a href="#已有储备" class="headerlink" title="已有储备"></a>已有储备</h1><h1 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h1><h3 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h3><p>eg:</p><p>在read的时候，如果fd被设置为阻塞IO(默认)，则会一直阻塞在read。</p><p>非阻塞在没有可读的buf时会返回。</p><p>设置文件描述符非阻塞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = fcntl(connfd, F_GETFL); <span class="comment">// get file flag</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(connfd, F_SETFL, flag); <span class="comment">// set file flag</span></span><br></pre></td></tr></table></figure><h1 id="Linux函数区别"><a href="#Linux函数区别" class="headerlink" title="Linux函数区别"></a>Linux函数区别</h1><p>read与recv的区别。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If a zero-length datagram is pending, read(2) and recv() with a flags argument of zero provide different behavior. In  this  circum‐stance, read(2) has no effect (the datagram remains pending), while recv() consumes the pending datagram</span><br></pre></td></tr></table></figure><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><h3 id="epoll-poll-select-区别"><a href="#epoll-poll-select-区别" class="headerlink" title="epoll poll select 区别"></a>epoll poll select 区别</h3><p>select 用数组来监听并轮询，poll 底层用链表来轮询（虽然能监听的文件描述符更多了，但本质和select类似），epoll 只返回有响应的几个事件</p><h3 id="epoll监听的事件"><a href="#epoll监听的事件" class="headerlink" title="epoll监听的事件"></a>epoll监听的事件</h3><ul><li><p>关于epoll_create一个疑问（已解决）：epoll_create(int size) 会限制监听最多为size的文件描述符，那不是和epoll_wait的max_event_len重复了? 实际上，现在版本的epoll_create只需要指定大于0的size即可，内核会自动调整。如果当前响应的文件描述符超过了max_event_len，那么会采用round robin的方式（轮询），避免饥饿。</p></li><li></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line"><span class="keyword">void</span>* ptr;</span><br><span class="line">   <span class="keyword">int</span> fd;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">epoll_event_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    int32 events; <span class="comment">//可添加的感兴趣事件，在触发时表示被触发的事件</span></span><br><span class="line">  <span class="keyword">epoll_event_t</span> data;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对epoll_event.events:</p><p>EPOLLIN: 有连接和数据in</p><p>EPOLLOUT: 缓冲区有数据写（如果不用EPOLLOUT而直接用send，可能会在缓冲区满时（此时数据可能还没写完）触发EAGAIN错误）</p><p>EPOLLRDHUP: 对端断开连接</p><p>EPOLLONESHOT: 对同一文件描述符上的事件只触发一次</p><h3 id="条件触发和边缘触发"><a href="#条件触发和边缘触发" class="headerlink" title="条件触发和边缘触发"></a>条件触发和边缘触发</h3><p>条件触发的意思是只要满足事件的条件，比如有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><p>IP地址范围</p><p><img src="https://static001.geekbang.org/resource/image/df/a9/df90239efec6e35880b9abe55089ffa9.jpg" alt="img"></p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo</title>
      <link href="/2021/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/muduo/"/>
      <url>/2021/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/muduo/</url>
      
        <content type="html"><![CDATA[<p>muduo学习</p><a id="more"></a><p>一些别人做的链接：</p><p><a href="https://github.com/iceCream1997/mini-muduo" target="_blank" rel="noopener">link1</a></p><p><a href="https://www.bilibili.com/video/BV1Zt411K7Gg?p=9" target="_blank" rel="noopener">好的讲解视频</a></p><h2 id="服务器介绍"><a href="#服务器介绍" class="headerlink" title="服务器介绍"></a>服务器介绍</h2><p><img src="/2021/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/muduo/image-20210219143036609.png" alt="image-20210219143036609"></p><p>服务器：网络I/O + 服务器处理 + 数据库</p><ul><li>队列 + 连接池(请求太多，没法一次全部处理完)</li><li>主要业务逻辑在应用服务器处理(在数据库慢很多？)</li><li>缓存更新(分布式缓存redis/memcached)</li></ul><p>数据库读写分离</p><p>应用服务器的负载均衡</p><h2 id="面向对象和基于对象"><a href="#面向对象和基于对象" class="headerlink" title="面向对象和基于对象"></a>面向对象和基于对象</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>继承</p><h3 id="基于对象"><a href="#基于对象" class="headerlink" title="基于对象"></a>基于对象</h3><h1 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h1><h2 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h2><p><img src="/2021/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/muduo/image-20210220110506608.png" alt="image-20210220110506608"></p><p>需要补充的东西：</p><p>CMakefile.txt怎么写</p><h2 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h2><p>__sync_val_compare_and_swap</p><p>P12跳过了</p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><h2 id="多线程高并发服务器"><a href="#多线程高并发服务器" class="headerlink" title="多线程高并发服务器"></a>多线程高并发服务器</h2><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>长连接，短连接</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><img src="/2021/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/muduo/image-20210220202857077.png" alt="image-20210220202857077"></p><p>惊群</p><p><img src="/2021/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/muduo/image-20210220203133436.png" alt="image-20210220203133436"></p><p>reactor</p><p>单线程轮询（无法利用多核cpu）</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动后台面试题</title>
      <link href="/2021/02/19/%E9%9D%A2%E8%AF%95/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95/"/>
      <url>/2021/02/19/%E9%9D%A2%E8%AF%95/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>面试问题</p><a id="more"></a><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>第一个题是输入一个数组，返回数组内数字能组成的 <a href="https://www.nowcoder.com/jump/super-jump/word?word=最大数" target="_blank" rel="noopener">最大数</a></p><p>[1,3,5] = 531</p><p>[1,10,45] = 45110</p><p>第二题是输入每个课程之间的关系，比如1-&gt;2，表示学习课程2需要先学习课程1，每轮学习课程 <a href="https://www.nowcoder.com/jump/super-jump/word?word=项目" target="_blank" rel="noopener">项目</a>不限，问最快几轮学习完之类的</p><p>蛇形或者说之字形遍历 <a href="https://www.nowcoder.com/jump/super-jump/word?word=二叉树" target="_blank" rel="noopener">二叉树</a></p><p>由于上面提到了<a href="https://www.nowcoder.com/jump/super-jump/word?word=红黑树" target="_blank" rel="noopener">红黑树</a>,追问<a href="https://www.nowcoder.com/jump/super-jump/word?word=红黑树" target="_blank" rel="noopener">红黑树</a>,然后问平衡树的定义</p><p>哈希冲突除了拉链法还有什么方法</p><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>TCP UDP相关知识 握手挥手之类的</p><p>Https建立连接的过程</p><p>状态码</p><p>重定向转发区别</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库索引，为什么用索引，索引数据结构。</p><p>索引的知识</p><p>ACID</p><p>事务并发的问题解决方法等</p><p>聚簇索引和非聚簇索引</p><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>问<a href>项目</a>:秒杀 数据丢失怎么处理 宕机怎么处理。我提了<a href>redis</a>增减的原子性+rocketmq事物+秒杀完之后通知openresty直接拦截请求进行服务降级,中途问了几个问题，反正也和数据丢失有关,我回答我的数据不丢失的前提只保证不超卖,然后反正围绕着<a href>redis</a>原子性操作和rocketmq的事物消息答出去了,答完面试官没追问了  </p><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>消息丢失?这个感觉问的很泛,不过再我的回答里面,是提到了主从防丢失 还有哨兵和cluster,然后补充了<a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>集群/哨兵是AP的系统</p><p>解释<a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a> RDB AOF</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库查询</title>
      <link href="/2021/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2/"/>
      <url>/2021/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>query processing</p><a id="more"></a><h1 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h1><p>How the system executes a query plan?</p><h2 id="Tree-approaches"><a href="#Tree-approaches" class="headerlink" title="Tree approaches"></a>Tree approaches</h2><ul><li>Iterator Model</li><li>Materialization Model</li><li>Vectorized / Batch Model</li></ul><h2 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h2><p>等价于next，有就return tuple，没有就返回null</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库课程笔记</title>
      <link href="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>事务和并发控制</p><a id="more"></a><p>好的中文翻译链接:</p><p><a href="https://developer.aliyun.com/article/754205" target="_blank" rel="noopener">link1</a></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217201252638.png" alt="image-20210217201252638"></p><h1 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h1><h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h2><p>log all actions</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217202823065.png" alt="image-20210217202823065"></p><h2 id="Shadow-paging-less-common"><a href="#Shadow-paging-less-common" class="headerlink" title="Shadow paging(less common)"></a>Shadow paging(less common)</h2><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217202913908.png" alt="image-20210217202913908"></p><h1 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h1><h1 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h1><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217205006805.png" alt="image-20210217205006805"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217205150976.png" alt="image-20210217205150976"></p><h2 id="Serializable-conflict"><a href="#Serializable-conflict" class="headerlink" title="Serializable conflict"></a>Serializable conflict</h2><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217215205244.png" alt="image-20210217215205244"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217211617184.png" alt="image-20210217211617184"></p><h2 id="pessimistic"><a href="#pessimistic" class="headerlink" title="pessimistic"></a>pessimistic</h2><p>Lock</p><p>(one lock)</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217215603060.png" alt="image-20210217215603060"></p><p>basic lock types</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217221131095.png" alt="image-20210217221131095"></p><h3 id="two-phase-locking"><a href="#two-phase-locking" class="headerlink" title="two-phase locking"></a>two-phase locking</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217221625466.png" alt="image-20210217221625466"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217221906581.png" alt="image-20210217221906581"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217221947795.png" alt="image-20210217221947795"></p><p>​                                                                    ||    ||    ||</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217222131181.png" alt="image-20210217222131181"></p><h3 id="2PL问题"><a href="#2PL问题" class="headerlink" title="2PL问题"></a>2PL问题</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217222239518.png" alt="image-20210217222239518"></p><h3 id="deadlock-detection-amp-handling"><a href="#deadlock-detection-amp-handling" class="headerlink" title="deadlock detection &amp; handling"></a>deadlock detection &amp; handling</h3><p>detection</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218093659092.png" alt="image-20210218093659092"></p><p>handling</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218093716213.png" alt="image-20210218093716213"></p><h3 id="Deadlock-prevention"><a href="#Deadlock-prevention" class="headerlink" title="Deadlock prevention"></a>Deadlock prevention</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210217230820569.png" alt="image-20210217230820569"></p><h3 id="Intention-lock"><a href="#Intention-lock" class="headerlink" title="Intention lock"></a>Intention lock</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218092110869.png" alt="image-20210218092110869"></p><ul><li>IS</li><li>IX</li><li>SIX</li></ul><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218092328410.png" alt="image-20210218092328410"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218093052331.png" alt="image-20210218093052331"></p><h1 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h1><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218093918990.png" alt="image-20210218093918990"></p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218094002463.png" alt="image-20210218094002463"></p><h2 id="How-to-allocate-the-timestamp"><a href="#How-to-allocate-the-timestamp" class="headerlink" title="How to allocate the timestamp"></a>How to allocate the timestamp</h2><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218094343494.png" alt="image-20210218094343494"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218094736460.png" alt="image-20210218094736460"></p><p>当前事务要比之前写该对象的事务更年轻，也就是进来的时候读到的数据已经被修改了</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218095302236.png" alt="image-20210218095302236"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218095707562.png" alt="image-20210218095707562"></p><h3 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218095536113.png" alt="image-20210218095536113"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218100357660.png" alt="image-20210218100357660"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218100118386.png" alt="image-20210218100118386"></p><p>会出现的问题：Ts Us Uw Tw(被忽略) Tc Uabort，Tw本来应该被保留但被忽略</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218101654941.png" alt="image-20210218101654941"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218101301911.png" alt="image-20210218101301911"></p><h3 id="Basic-I-O的问题"><a href="#Basic-I-O的问题" class="headerlink" title="Basic I/O的问题"></a>Basic I/O的问题</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218111237260.png" alt="image-20210218111237260"></p><h2 id="OPTIMISTIC-CONCURRENCY-CONTROL"><a href="#OPTIMISTIC-CONCURRENCY-CONTROL" class="headerlink" title="OPTIMISTIC CONCURRENCY CONTROL"></a>OPTIMISTIC CONCURRENCY CONTROL</h2><p>When a txn commits, the DBMS compares workspace write set to see whether it conflicts with other txns.</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218110522070.png" alt="image-20210218110522070"></p><p>validation intersection分forward validation 和 backward validation</p><p>forward validation: 查看intersection在当前事务之前提交的事务，保证</p><h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h3 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218164759479.png" alt="image-20210218164759479"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218165826744.png" alt="image-20210218165826744"></p><h2 id="Design-MVCC"><a href="#Design-MVCC" class="headerlink" title="Design MVCC"></a>Design MVCC</h2><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218165859205.png" alt="image-20210218165859205"></p><p>Concurrency Control Protocol</p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218165946075.png" alt="image-20210218165946075"></p><h2 id="Version-storage"><a href="#Version-storage" class="headerlink" title="Version storage"></a>Version storage</h2><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218170255824.png" alt="image-20210218170255824"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218170408819.png" alt="image-20210218170408819"></p><h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218170608433.png" alt="image-20210218170608433"></p><h3 id="Time-tranversal"><a href="#Time-tranversal" class="headerlink" title="Time-tranversal"></a>Time-tranversal</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218172344883.png" alt="image-20210218172344883"></p><h3 id="Delta"><a href="#Delta" class="headerlink" title="Delta"></a>Delta</h3><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218172254568.png" alt="image-20210218172254568"></p><h2 id="Garbage-collection"><a href="#Garbage-collection" class="headerlink" title="Garbage collection"></a>Garbage collection</h2><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218172911806.png" alt="image-20210218172911806"></p><p><img src="/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210218173006328.png" alt="image-20210218173006328"></p><p>看到这儿了</p><p><a href="https://youtu.be/E4u4ogqfEIA?list=PLSE8ODhjZXjbohkNBWQs_otTrBTrjyohi&amp;t=2492" target="_blank" rel="noopener">https://youtu.be/E4u4ogqfEIA?list=PLSE8ODhjZXjbohkNBWQs_otTrBTrjyohi&amp;t=2492</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料</title>
      <link href="/2021/02/17/%E8%B5%84%E6%96%99/%E8%B5%84%E6%96%99/"/>
      <url>/2021/02/17/%E8%B5%84%E6%96%99/%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<p>面试资料整理</p><a id="more"></a><h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><h2 id="TCP问题系列问题"><a href="#TCP问题系列问题" class="headerlink" title="TCP问题系列问题"></a>TCP问题系列问题</h2><p><a href="https://mp.weixin.qq.com/s/6LiZGMt2KRiIoMaLwx-lkQ" target="_blank" rel="noopener">link1</a></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><a href="https://time.geekbang.org/column/article/67888" target="_blank" rel="noopener">极客时间数据库MySQL实战45讲</a></p><p><a href="https://blog.csdn.net/ThinkWon/article/details/104778621" target="_blank" rel="noopener">数据库博客</a></p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><a href="https://cloud.tencent.com/developer/user/5465588" target="_blank" rel="noopener">Linux内核博客</a></p><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p><a href="https://github.com/qinguoyi/TinyWebServer" target="_blank" rel="noopener">Tiny web 详细教程</a></p><p><a href="https://github.com/saminiir/level-ip" target="_blank" rel="noopener">实现user_level TCP协议栈</a></p><p><a href="https://blog.csdn.net/xpy870663266/article/details/78163423" target="_blank" rel="noopener">SimpleDB</a></p><h2 id="muduo"><a href="#muduo" class="headerlink" title="muduo"></a>muduo</h2><p><a href="https://www.bilibili.com/video/BV16V411k7eF?p=1" target="_blank" rel="noopener">preliminary(CMakelists.txt)</a></p><p><a href="https://blog.csdn.net/u012997311/article/details/79288696" target="_blank" rel="noopener">怎么使用muduo</a></p><p><a href="https://www.bilibili.com/video/BV1Zt411K7Gg?from=search&seid=479800820188220744" target="_blank" rel="noopener">muduo视频教程</a></p><h1 id="Competitive-Programming"><a href="#Competitive-Programming" class="headerlink" title="Competitive Programming"></a>Competitive Programming</h1><p><a href="https://github.com/hzwer/shareOI" target="_blank" rel="noopener">PPT</a></p><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><p><a href="https://www.nowcoder.com/discuss/590130?type=post&order=time" target="_blank" rel="noopener">c++经验</a></p><p><a href="https://github.com/521xueweihan/HelloGitHub" target="_blank" rel="noopener">神仙项目网站</a></p><p><a href="https://godweiyang.com/2020/04/24/leetcode-conclusions-110/" target="_blank" rel="noopener">godweiyang刷题博客</a></p><p><a href="https://github.com/zqy1018/my_leetcode" target="_blank" rel="noopener">zqy1018大佬周赛</a></p><p><a href="https://blog.csdn.net/weixin_40771521/article/details/103893982" target="_blank" rel="noopener">word2vec详解</a></p><p><a href="https://blog.csdn.net/armlinuxww/article/details/92803381" target="_blank" rel="noopener">epoll详解</a></p><p><a href="http://froghui.github.io/" target="_blank" rel="noopener">fronthui大佬对常用组件比较深的挖掘</a></p>]]></content>
      
      
      <categories>
          
          <category> 资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pygame</title>
      <link href="/2021/01/09/%E6%B8%B8%E6%88%8F/pygame/"/>
      <url>/2021/01/09/%E6%B8%B8%E6%88%8F/pygame/</url>
      
        <content type="html"><![CDATA[<p>pygame矩形位置</p><a id="more"></a><p>游戏动画实质是 update img</p><p>pygame从开始到结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pygame.init()</span><br><span class="line"></span><br><span class="line">game logic and canvas update</span><br><span class="line"></span><br><span class="line">pygame.quit()</span><br></pre></td></tr></table></figure><p>rect图：</p><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3476901310,301297795&fm=26&gp=0.jpg" alt="img"></p><p><img src="/2021/01/09/%E6%B8%B8%E6%88%8F/pygame/image-20210109174636059.png" alt="image-20210109174636059"></p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试准备</title>
      <link href="/2021/01/05/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
      <url>/2021/01/05/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>Faiss 和 一些leetcode的题目</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>http1.0 </p><p>content type</p><p>http1.1</p><p>非规范的keep alive</p><p>http2.0    </p><h2 id="内涵"><a href="#内涵" class="headerlink" title="内涵"></a>内涵</h2><ol><li>Content-Length</li><li>Content-Type：用json，protobuf等传输时指定</li></ol><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>cwnd限制速率 $|lastByteSent - lastByteAck| &lt; min{cwnd, rwnd}$</p><ul><li><p>快重传</p><p>​    接收方每收到一个失序分组就发出重复确认，累计收到3个重复的ack则认为丢包（不会等计时器超时再重传）</p></li><li><p>慢启动</p><p>​    一个RTT，cwnd指数大小增加</p></li><li><p>拥塞避免</p><p>​    刚开始是和慢启动一样，达到ssthresh线性增长，增长策略是每个RTT（一个ACK可能是对多个包的确认），cwnd + 1。</p></li></ul><ul><li><p>快速恢复（TCP Reno）</p><p>​    “乘性减小”</p><p>​    收到连续三个重复ack，ssthresh（门限）减半（有的会加上3个MSS），之后再线性增加cwnd，进入拥塞避免阶段。</p></li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>进程</p><p>地址空间</p><p>​    mmap</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>操作系统多线程</p><a id="more"></a><h2 id="多线程会产生的问题"><a href="#多线程会产生的问题" class="headerlink" title="多线程会产生的问题"></a>多线程会产生的问题</h2><p>$+$操作其实会被解构为：取值(move)，加(add)，存值(move)三个操作。多线程加会出现很多意想不到的结果。</p><p>解决方案：加锁</p><h2 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h2><h3 id="naive-sol"><a href="#naive-sol" class="headerlink" title="naive sol"></a>naive sol</h3><p>lock为1时忙等，为0时加锁并进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (lock);</span><br><span class="line">lock = <span class="number">1</span></span><br><span class="line">\\ handle things</span><br><span class="line">lock = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>问题：可能在while判断时该线程就被切换，导致多个线程同时进入临界区</p><p>正确性：×</p><p>效率：低</p><p>因此需要保证在看到锁的时候就立马上锁，这两个操作不能分开。</p><h3 id="硬件保证"><a href="#硬件保证" class="headerlink" title="硬件保证"></a>硬件保证</h3><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>如果获得锁就进入临界区，否则等待。TetsAndSet是原子操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;lock, <span class="number">1</span>) == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>问题：如果线程切换，会遇到多个线程忙等的状态，浪费时间。</p><p>正确性：√</p><p>效率：低</p><p>解决1：考虑在自旋的过程中<strong>关中断</strong>，避免线程切换。但存在的问题是：如果长时间关中断可能会造成中断丢失的现象，这种方案只对线程短时间阻塞的情况适用</p><p>解决2：考虑没拿到锁就执行<strong>yield</strong>，让出cpu资源。但也不能从根本上解决问题，可能会切换多个线程都执行yield</p><p>解决3：用一个<strong>阻塞队列</strong>来存放没拿到锁的线程，线程发现自己阻塞就把自己加入队列中，否则则进入临界区。每当临界区中的线程结束后，就会把队头的线程取出执行。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>与互斥没本质区别，但同步更强调的是线程之间的协作，某个线程达到某个状态后唤醒另一线程。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件满足：唤醒一个或所有线程，否则：等待</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(cv) <span class="comment">// wait condition variable</span></span><br><span class="line">signal/notify(cv) <span class="comment">//唤醒一个</span></span><br><span class="line">broadcast/notifyall <span class="comment">//唤醒所有</span></span><br></pre></td></tr></table></figure><p>条件变量一般会和互斥锁一起使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex)</span><br><span class="line">wait(&amp;cv, &amp;mutex)</span><br><span class="line">mutex_unlock(&amp;mutex)</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>生产者执行的条件是：缓冲区没满</p><p>消费者执行的条件是：缓冲区没空</p><p>可以用两个条件变量指示</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2周总结</title>
      <link href="/2021/01/04/%E6%80%BB%E7%BB%93/%E7%AC%AC2%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/04/%E6%80%BB%E7%BB%93/%E7%AC%AC2%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结tried，入党，完成开题</p><a id="more"></a><h3 id="1月4日"><a href="#1月4日" class="headerlink" title="1月4日"></a>1月4日</h3><p>总结了tried，补了之前的几个题，花了一上午，有点不值，主要昨天还是12点30睡，今早7点就醒了，然后就没有继续睡着了。下午就把zq的论文给改好了提交（做这个事实在没什么干劲，自己word水平也不行)，晚上回来把入党的ppt做了，但其实也做的不好，怎么用合理的时间完成自己不喜欢的事情也是我之后要考虑解决的。</p><p>明天复习多线程（动手写程序）并完成开题ppt吧。</p><h3 id="1月5日（补）"><a href="#1月5日（补）" class="headerlink" title="1月5日（补）"></a>1月5日（补）</h3><p>心情有点down，发展对象14选11，没选到我，一个是自己简历上活动和学习强国积分不行，另外则是答辩一些东西表达不好，也是自己没有好好背，脑子里没装东西的原因。</p><p>多线程一种万能写法掌握了：条件变量 + 锁</p><h3 id="1月6日"><a href="#1月6日" class="headerlink" title="1月6日"></a>1月6日</h3><p>复习了多线程，读者写者哪个优先有点没太明白，心情不太好，有点down，受到昨天影响了，下午和甘老师一行去浦东开发区学习了一下浦东的发展历史，还是挺有收获，开阔了一点视野。</p><h3 id="1月10日"><a href="#1月10日" class="headerlink" title="1月10日"></a>1月10日</h3>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化数据结构</title>
      <link href="/2021/01/04/Algorithm/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2021/01/04/Algorithm/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>在更新过程中拓扑序不发生改变的数据结构可以进行可持久化的操作，如seg tree, fin tree, tri tree. 而平衡树不能进行持久化因为左旋右旋可能会改变其拓扑序（clj大佬说平衡树可以TaT)</p><a id="more"></a><h1 id="概念和性质"><a href="#概念和性质" class="headerlink" title="概念和性质"></a>概念和性质</h1><p>可持久化可以存下来数据结构的所有历史版本（有点类似git的操作），而为了节省记录空间，每次只记录与前一个版本不同的节点</p><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2021/01/04/Algorithm/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210104104856924.png" alt="image-20210104104856924"></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="区间异或值最大"><a href="#区间异或值最大" class="headerlink" title="区间异或值最大"></a>区间异或值最大</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithm/算法提高课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021第二周</title>
      <link href="/2021/01/04/%E6%AF%8F%E5%91%A8%E5%81%9A%E9%A2%98/2021%E7%AC%AC%E4%BA%8C%E5%91%A8/"/>
      <url>/2021/01/04/%E6%AF%8F%E5%91%A8%E5%81%9A%E9%A2%98/2021%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<p>复习trie、每日一题、周赛</p><a id="more"></a><p>tri解决字符串查询和异或对：acw 835，acw 143，LC 421，LC 1707</p><p>补题：lc 960 lc 646 lc 757 lc 1235</p><p>1月6日</p><p>399 除法求值(floyd)</p><p>1月7日</p><p>面了旷视，吃了年会的饭，明天答辩，今天好冷…希望有offer吧</p><h3 id="1月10日"><a href="#1月10日" class="headerlink" title="1月10日"></a>1月10日</h3><p>周赛四题，但感觉自己的问题越来越严重，对于思考的深度越发不足，比较浮躁</p><p>把做题和总结分开感觉有点麻烦，之后就开每日总结了，这个directory就关了</p>]]></content>
      
      
      <categories>
          
          <category> 每周做题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/2021/01/04/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2021/01/04/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#head1"> 概念和性质</a></li><li><a href="#head2"> 变例</a><ul><li><a href="#head3"> 最朴素的tried树</a></li><li><a href="#head4"> 用于异或查值的tried树</a></li></ul></li><li><a href="#head5"> 总结</a></li></ul><p>字典树（tried）是处理字符串查找和最大异或值的数据结构。</p><a id="more"></a><h1 id="概念和性质"><a href="#概念和性质" class="headerlink" title=" 概念和性质"></a><span id="head1"> 概念和性质</span></h1><p>树上节点存的是字符串（或数的二进制表示）中的某一位，每个节点都会有一个编号以唯一区分该节点和其他节点</p><p>核心更新步骤：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前要加入的节点没有编号，则对其进行编号并移动到该节点</span></span><br><span class="line"><span class="keyword">if</span> (!tr[p][cur]) tr[p][cur] = idx ++;</span><br><span class="line">p = tr[p][cur];</span><br></pre></td></tr></table></figure><h1 id="变例"><a href="#变例" class="headerlink" title=" 变例"></a><span id="head2"> 变例</span></h1><h2 id="最朴素的tried树"><a href="#最朴素的tried树" class="headerlink" title=" 最朴素的tried树"></a><span id="head3"> 最朴素的tried树</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nxt[p][cur]) nxt[p][cur] = idx ++;</span><br><span class="line">        p = nxt[p][cur];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nxt[p][cur]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = nxt[p][cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[p]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用于异或查值的tried树"><a href="#用于异或查值的tried树" class="headerlink" title=" 用于异或查值的tried树"></a><span id="head4"> 用于异或查值的tried树</span></h2><p>注：</p><ol><li>最好写$x &gt;&gt; i &amp;1$ 而不是$x &amp;1 &lt;&lt; i$ (避免溢出)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; i --) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tr[p][cur])    tr[p][cur] = idx ++;</span><br><span class="line">        p = tr[p][cur];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; i --) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[p][!cur]) cur = !cur, ret += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        p = tr[p][cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：</p><p>LC 421,  LC 1707</p><h1 id="总结"><a href="#总结" class="headerlink" title=" 总结"></a><span id="head5"> 总结</span></h1><ul><li>tried树每个节点都有一个编号，每次更新一个节点就需要同时更新编号的值</li><li>tried树可以拓展用于异或对，从最高位开始进行判定，处理求异或最大值的问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学课程</title>
      <link href="/2021/01/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"/>
      <url>/2021/01/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>南京大学操作系统课程笔记</p><a id="more"></a><p>(前几趴待总结下)</p><h1 id="P5-线程互斥"><a href="#P5-线程互斥" class="headerlink" title="P5 线程互斥"></a>P5 线程互斥</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>多线程 = 多个线程 + 共享内存</p><p>互斥：原子性</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>对共享内存支持的操作</p><ul><li>load</li><li>store</li><li>本地计算（仅线程自身可见）</li></ul><p>多线程令人费解的结果的原因？</p><p>多线程求 1 + 1 + 1 $\cdots$ (n 个 1相加)</p><p>结果可能小于n，大于n</p><p>解释1：</p><p>add程序的本质</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = load(x);</span><br><span class="line">t ++;</span><br><span class="line">store(x, t)</span><br></pre></td></tr></table></figure><p>解释2：</p><p>可能某个程序待存的数据x在缓存中，另一个程序load x还是原来的x，缓存在线程和共享内存之间。</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>共享内存 load/store可能乱序，无法实现互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = load(x)</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">0</span>) store(x, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>以上的指令被称为：test and set</p><p>需要硬件为我们保证以上两个指令的原子性</p><h3 id="LR-SC"><a href="#LR-SC" class="headerlink" title="LR/SC"></a>LR/SC</h3><p>​    LR  (x)(标记)-&gt;[本地计算]-&gt;SC(x)（满足条件再存储）</p><h1 id="测试程序："><a href="#测试程序：" class="headerlink" title="测试程序："></a>测试程序：</h1><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p><img src="/2021/01/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/image-20210103181307787.png" alt="image-20210103181307787"></p><p>objdump -d sum.out | less</p><p>time ./sum.out </p><h2 id="exchange指令"><a href="#exchange指令" class="headerlink" title="exchange指令"></a>exchange指令</h2><p><img src="/2021/01/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/image-20210103181546386.png" alt="image-20210103181546386"></p><p>xchg(addr, 1)</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p><img src="/2021/01/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/image-20210103181848865.png" alt="image-20210103181848865"></p><p><img src="/2021/01/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/image-20210103182108129.png" alt="image-20210103182108129"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab设置</title>
      <link href="/2021/01/02/%E6%95%B0%E6%8D%AE%E5%BA%93/lab%E8%AE%BE%E7%BD%AE/"/>
      <url>/2021/01/02/%E6%95%B0%E6%8D%AE%E5%BA%93/lab%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<ul><li>docker运行容器</li><li>测试</li></ul><a id="more"></a><ol><li><p>docker 运行ubuntu环境</p><ol><li><p>创建</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -it -v D:\计算机课程\bustup:/home/ ubuntu:v2 /bin/bash</span></span><br></pre></td></tr></table></figure></li><li><p>查看现有运行的容器:</p><p>docker ps</p></li><li><p>运行现有容器</p><p>docker exec -it 05eff3fa95d7 /bin/bash</p></li><li><p>保存记录</p><p>docker commit -a “lighteningzhang” -m “change” a404c6c174a2  ubuntu:v3</p></li><li><p>docker 关闭所有容器</p><p>docker stop $(docker ps -aq)</p></li></ol></li></ol><p>   2.测试</p><p>   测试代码</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gtest/gtest.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123; </span><br><span class="line">       <span class="comment">//testing::GTEST_FLAG(output) = "xml:"; //若要生成xml结果文件</span></span><br><span class="line">       testing::InitGoogleTest(&amp;argc,argv); <span class="comment">//初始化 </span></span><br><span class="line">       RUN_ALL_TESTS(); <span class="comment">//跑单元测试 </span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s /home/build/lib/libbustub_shared.so /usr/lib</span><br><span class="line"></span><br><span class="line">ln -s /home/build/lib/libgtest.so /usr/lib</span><br></pre></td></tr></table></figure><p>ln -s /home/build/lib/libgtest.so.1.10.0 /usr/lib</p><p>   sudo ldconfig</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">需要链接的库和文件：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">-I&#x2F;home&#x2F;src&#x2F;include&#x2F; -I&#x2F;home&#x2F;build&#x2F;googletest-src&#x2F;googletest&#x2F;include&#x2F; -L&#x2F;home&#x2F;build&#x2F;lib&#x2F;libgtest.a -lgtest -lpthread -lbustub_shared</span><br></pre></td></tr></table></figure><p>   步骤1. 创建一个main_test文件</p><p>   步骤2. 编译所有单元测试文件生成 .o</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o t.o -c test.cpp -I/home/src/include/ -I/home/build/googletest-src/googletest/include/ -L/home/build/lib/ -lgtest -lpthread</span><br></pre></td></tr></table></figure><p>   步骤3. 链接所有.o文件，最后生成可执行文件</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main *.o -I/home/src/include/ -I/home/build/googletest-src/googletest/include/ -L/home/build/lib/ -lgtest -lpthread -lbustub_shared</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1周总结</title>
      <link href="/2021/01/02/%E6%80%BB%E7%BB%93/%E7%AC%AC1%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/02/%E6%80%BB%E7%BB%93/%E7%AC%AC1%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>1月1日~1月3日</p><p>第一周只有三天（周五、周六、周天）</p><a id="more"></a><h3 id="1月1日"><a href="#1月1日" class="headerlink" title="1月1日"></a>1月1日</h3><p>折腾了下博客，其他时间在玩</p><h3 id="1月2日"><a href="#1月2日" class="headerlink" title="1月2日"></a>1月2日</h3><p>呆在宿舍，下午4点30和室友去吃了顿饭（天辣）</p><p>想做cmu数据库的lab，但不知道环境怎么配，折腾了很久，网上也没有说明，对于cpp的一些报错不知道怎么解决。和朋友聊了下天，了解大家的情绪其实都不太好，大家都不容易，需要调整自己的心态和情绪，不仅要展望远方，也要把握自己的“附近”。</p><p>之后数据库就看视频和书总结吧…确实不能再这样耽搁了，刷题现在也没有激情，心态还是没调整好。</p><h3 id="1月3日"><a href="#1月3日" class="headerlink" title="1月3日"></a>1月3日</h3><p>本周最后一天。感觉不太在状态，最近。好一点的状态是之前10月左右在图书馆刷提高课最短路进阶部分的时候，就是没那么浮躁，现在还是没太调整过来，这部分情绪其实找人聊天是解决不了的，还是得自己想办法进行focus。</p><p>上午做了打卡题和周赛，周赛明显感觉focus不了，思绪太乱，理不清，找不到解决问题直观的想法，这一点就说明大脑是相当混乱。一方面是因为最近心态不好，没规划好刷题、工作、生活，另一方面是脑子看事情走偏了，没有在一个比较正确的轨道上，心态也因此没调整过来。</p><p>下午休息了会儿，学习并upsolving了周赛的后两题，但去实验室休息室的沙发上没睡着，下午精神不太好，完成了老师要求的一个结题报告，发现自己之前有些地方竟然完全没仔细看就把一些材料黏贴上去了，虽然博士师兄帮我纠正过来了，但我也意识到自己做工作是真的有点离谱…</p><p>这周是开年的第一周，只有三天，自己状态不是很好，还是源于去年的状态。有些思绪没调理过来。但不会有这么多时间给我来调整，需要我自己focus到每件事上。</p><h3 id="接下来一周"><a href="#接下来一周" class="headerlink" title="接下来一周"></a>接下来一周</h3><p>接下来一周要完成的任务</p><ul><li><p>开题答辩ppt及准备（周一4号）</p></li><li><p>入党ppt及材料准备（周一4号）</p></li><li><p>完成入党答辩（周二5号）</p></li><li><p>练熟开题ppt要讲的内容（周二5号）</p></li><li><p>学习南京大学操作系统课程和数据库课程</p></li></ul><p>  此外，刷题是每天必须做的</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021第一周</title>
      <link href="/2021/01/01/%E6%AF%8F%E5%91%A8%E5%81%9A%E9%A2%98/2021%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
      <url>/2021/01/01/%E6%AF%8F%E5%91%A8%E5%81%9A%E9%A2%98/2021%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<p>每日一题、周赛</p><a id="more"></a><p>待补：Tried 在异或上的应用：acw 143, LC 421, LC 1707</p><h2 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h2><p>Leetcode 435 无重叠区间：其实是找区间不重叠最大数量，简单贪心</p><p>LC 605 种花，简单贪心</p><p>LC 452 <a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons" target="_blank" rel="noopener"> Minimum Number of Arrows to Burst Balloons</a> ，最小数覆盖所有区间，直观的右端点排序贪心，如果是左端点排，需要不断更新右端点最小值。</p><p>LC 86 分隔链表，模拟</p><h2 id="周赛"><a href="#周赛" class="headerlink" title="周赛"></a>周赛</h2><p>周赛拉跨，做了两题    第二题还wa了两次，第三题有思路，一个lower_bound确定下界，一个upper_bound确定上界，但脑子不太清晰，瞎做了半天，赛后才有清楚的思路。第四题赛后看了下是求最长公共子序列，但数据范围不允许朴素做法，可以根据下标转换为最长上升子序列求解(dp当前index对应的值是target中的下标)</p><p>第二题$2^{20} + 2^{20}$一开始竟然想成了$2^{40}$，最近刷题状态确实不好</p><p>第三题其实就是二分，但想的太琐碎了，没有一个比较直观的视角</p><p>第四题如果不知道这个思路自己应该还是想不出来，也有up主用线段树解的(思想是类似，但没太看懂)，线段树和dp都还要复习下。</p>]]></content>
      
      
      <categories>
          
          <category> 每周做题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020年终总结</title>
      <link href="/2020/12/31/%E6%80%BB%E7%BB%93/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2020/12/31/%E6%80%BB%E7%BB%93/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li>做事抓重点（不管再难懂的概念都能用一句话简单表达出来，不然其实自己并没理解）</li><li>文件管理（文件命名和log很重要）</li><li>技术深度（类似先dfs再bfs）</li><li>每段时间能进行转化</li><li>总结成为自己的体系（系统性的覆盖面）</li></ul><a id="more"></a><p>以上几点大概是我2020的一点体会吧，这些也是我以前忽视掉的点。</p><p>2020年的1月20号我从学校回家，坐的是第z257次列车，本来准备休息两周，2月9号就回学校，没想到直接呆到了6月29号再回来。在家的这段时间，现在留给我的印象几乎就是空白，虽然在zoom上把课程全部上完了，现在也记得有最优化、图与网络、大规模数据、学术英语等，但说实话，这些课程收获不大，一个是自己没太下功夫，还有就是确实课程与科研偏离比较多，对自己长期的发展没有直接的帮助，现在想来花在这些课上的大部分就是为了完成任务，以至于回想起来没啥感觉。在家收获最大的其实就是入了acwing的坑，把基础课刷完了(差不多从3月到6月)，比起自己在学校瞎搞的，确实要系统很多，这个对我帮助还是挺大的，我后续又买了提高课和进阶课（但没刷多少）。4月的时候科研有了点idea，但那个时候自己对于怎么发论文、写论文，没什么概念，实验是做了，但也不知道进一步怎么开展，老师对我这方面不怎么关注，我也就在科研上划水了。</p><p>回学校之后，基本就是暑假了，参与了大课题组的一些打杂事务，大致就是用python处理数据。收获比较大的就是参加了暑期开源计划2020，给milvus社区贡献代码（这里要感谢Grigometh(谢总)推荐给我这个活动），参与这个大型项目的开发让我踩了很多坑（编译、阅读、调试代码），有几天晚上熬夜到了2点，虽然最后实际代码其实没写多少，但我明白了自己很多的不足之处，以及明白文件管理和笔记管理的重要性。</p><p>9月中旬之后又开始刷题，只是进度很慢…到了10月开始写论文，实际上大部分时间是拿去刷题了，经常写着写着就去干别的…面试了腾讯视频推荐算法实习过了，给了我不少信心，后来想起来不过是人家缺人而已。11月面了亚马逊ai lab，代码都写出来了，但机器学习有的问题没答好，科研有个地方口胡了，并且被面试官追问了，在那之后我面试说话都谨慎了很多…一点大话不敢说…疫情在家也刷了统计学习方法的代码，但只刷了一半且没总结，导致最后差挺多的…科研也是，某些地方看着觉得原理差不多了，就没深究了…12月面了字节，问题很多和面经一样，但我没准备数据库，某些问题组织的也不太好，考的代码基本也是原题，只是好几个月之前做的，没写出最优解，一面挂了…还面了依图，二面有些问题答得一般，多线程没准备，设计模式没看过也没写出来，就写出了代码题，现在还在泡池子…</p><p>总之感觉自己以前是真的幼稚（无论是技术还是心理），这一年心理成长了一些，但做事毫无计划性，导致回想某个时间段根本想不起来干了些啥…有很多时候也重复了之前的错误，比如不重视基础直接肝高阶一点的东西，短期来看确实还有点成就感，但长期来看其实会浪费时间且不系统。要提升的地方还有很多，不过控制大脑在无意义的问题上的思考应该是我首先要解决的…希望今年能得到一些offer（字节抬我一手），并且技术上有一点成长，做一些阶段性的计划和总结…差不多这样吧…</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬币方案数</title>
      <link href="/2020/08/13/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%A1%AC%E5%B8%81%E6%96%B9%E6%A1%88%E6%95%B0/"/>
      <url>/2020/08/13/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%A1%AC%E5%B8%81%E6%96%B9%E6%A1%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定面值的几个硬币(1, 5, 10, 25)，用它们组成n，求方案数。leetcode <a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">链接</a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>很容易想到该问题有点像完全背包问题，用完全背包来写很快就得到解决方案了。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统/系统级IO</title>
      <link href="/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/"/>
      <url>/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="系统级I-O"><a href="#系统级I-O" class="headerlink" title="系统级I/O"></a>系统级I/O</h1><p>I/O即输入/输出(input/output)，是在主存和外部设备之间<strong>拷贝</strong>数据的过程。输入操作是从I/O设备拷贝数据到主存，输出操作是从主存拷贝数据到I/O设备。</p><a id="more"></a>     <h2 id="Unix-IO"><a href="#Unix-IO" class="headerlink" title="Unix IO"></a>Unix IO</h2><p>Unix文件就是一个字节序列：</p><p>$$ B_0B_1\cdots B_n $$</p><p>所有的I/O设备都被模型化为文件，所有的输入输出都被当做文件来读和写来执行。将设备映射为文件, Linux内核引出了一个简单、低级的应用接口，使得所有的输入输出都以一致的方式来执行：</p><ul><li><p>打开文件。一个应用程序要通过内核打开相应的文件，来宣告它想访问一个I/O设备。调用操作系统提供的服务，内核返回一个非负整数，称为<strong>文件描述符</strong>。后续操作传入这个标识符即可。内核记录有关打开这个文件的所有信息，应用程序只用记录描述符。Linux shell创建的每个进程开始都有三个打开的文件：标准输入(描述符为0)、标准输出（描述符为1）、标准错误（描述符为2）。</p></li><li><p>改变当前的文件位置</p><p>对每个打开的文件，内核保持着一个文件位置k，初始为0。这个位置是从文件开头起始的字节偏移量。应用程序可以通过seek操作，显式地指定k。</p></li><li><p>读写文件</p><p>读操作是文件复制n个字节到内存（一般配合缓冲区），然后将k增加到k+n。长度为m字节的文件，当k&gt;=m时，指定读操作会触发EOF（end of file)。(文件结尾并未明确“EOF”符号)</p></li><li><p>关闭文件</p><p>应用程序通知内核关闭文件。内核释放文件打开时创建的数据结构，将描述符恢复到描述符池中。无论一个进程因为哪种原因终止，内核都会关闭所有打开的文件并释放他们的内存资源。</p></li></ul><h2 id="内核结构"><a href="#内核结构" class="headerlink" title="内核结构"></a>内核结构</h2><p>内核用三个相关的数据结构来表示打开的文件。</p><ol><li><p>描述符表，每个进程都有自己的描述符表，表项由进程打开的文件描述符来索引，每个表项指向文件表中的一个表项。</p></li><li><p>文件表</p><p>文件表存放在内核空间，由系统所有进程共享。每个表项由如下组成：</p><ol><li>当前文件位置</li><li>引用计数</li><li>指向v-node表中对应表项的指针</li></ol><p>关闭一个描述符会减少对应文件表项中的引用计数。当引用计数为0时，内核删除这个文件表项。</p></li><li><p>索引节点表也存放在内核空间，由所有进程共享</p></li></ol><p>多个描述符也可以通过不同的文件表项来引用同一个文件。如对同一个filename进行两次open操作</p><p><img src="/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/image-20200805100032153.png" alt="image-20200805100032153"></p><p>父子共享文件如下图：</p><p><img src="/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/image-20200805100210583.png" alt="image-20200805100210583"></p><p>子进程有一个父进程描述符表的副本。在内核删除对应文件表之前，父子进程都必须关闭描述符。</p><p>一个进程对于某个文件描述符的操作也会反应到另一个进程中。</p><h2 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h2><p><img src="/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/image-20200805100751094.png" alt="image-20200805100751094"></p><p>IO重定向就是把文件描述符修改为其他对应的内容。</p><h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><p>C语言定义了一组高级输入输出函数，为标准I/O库。</p><ol><li>打开和关闭文件 fopen/fclose</li><li>读写字节 fread/fwrite</li><li>读写字符串 fgets/fputs</li><li>格式化IO scanf/printf</li></ol><p>标准io库将打开的文件模型化为一个流，一个流就是一个指向FILE类型的指针。类型为FILE的流是对文件描述符和流缓冲区的抽象。使用缓冲区的目的是减少开销较高的Linux I/O系统调用。先对缓冲区操作，然后缓冲区满之后再用系统调用进程操作。</p><p><img src="/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/image-20200805105913298.png" alt="image-20200805105913298"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号</title>
      <link href="/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7/"/>
      <url>/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>Unix信号是一种较高层的软件形式的异常，它允许进程中断其他进程。信号可以看作一种小道消息，它通知系统发生了某种类型的<strong>事件</strong>。</p><a id="more"></a><p>linux上支持30种不同的信号，如下表所示：</p><p><img src="/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7/image-20200804091332871.png" alt="image-20200804091332871"></p><p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常程序处理的，正常情况下对用户进程是不可见的。信号则提供了一种机制，即通知用户发生了这些异常。比如：用户在键入<code>ctrl-c</code>内核就会发送<code>SIGINT</code>信号给该进程；一个进程也可以发送<code>SIGKILL</code>给另外一个进程来强制终止它；当子进程终止或者停止时，内核会发送<code>SIGCHLD</code>信号给父进程。</p><h2 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h2><ol><li><p>发送信号</p><blockquote><p>发送信号可能有如下两种原因：</p><p>1) 内核检测到一个系统事件(如子进程终止或被0除)</p><p>2) 一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程</p></blockquote></li><li><p>接收信号</p><blockquote><p>当目的进程被 内核 强迫以某种方式做出反应时，目的进程就接收了信号。用户可以通过信号处理器(signal handler)来捕获这个信号，用户也可以忽略这个信号。</p></blockquote></li></ol><p>信号处理如下图：接收到信号会触发控制转移到信号处理程序。在信号处理完成后，控制会返回到被中断的程序。</p><p><img src="/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7/image-20200804093805046.png" alt="image-20200804093805046"></p><p>​        一个发出而未被接收的信号称为<em>待处理信号</em>。任何时刻，一种类型至多会有一个待处理信号。如果一个进程有某个类型的待处理信号（如类型为k），则接下来发送到这个进程的类型为k的信号都不会排队等待(排队队长最多为1)，它们只是被简单的丢弃。一个进程可以<strong>阻塞</strong>的接收某种信号。当一个信号被阻塞时，它仍可以被发送，但产生的待处理信号不会被接收。</p><p>以下程序为接收SIGINT信号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signal)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Receive SIGINT"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (signal(SIGINT, handler) == SIG_ERR)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Signal Error\n"</span>);</span><br><span class="line">   sleep(<span class="number">10</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在sleep的过程中接收信号，在处理信号后，会跳到sleep的下一行进行（sleep失效）。</p><p>由上述可以看出，信号也是实现进程间通信的一种方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>信号概念</li><li>发送/接收信号</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2020/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/"/>
      <url>/2020/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>下面主要介绍进程相关的一些基本概念</p><p>[TOC]</p><a id="more"></a><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>common knowledge:</p><ol><li><p>每个进程有唯一的id。</p></li><li><p>进程总处于三个状态(运行，停止，终止)</p></li></ol><p>关于进程的三个状态，其中</p><ul><li>运行状态包含执行和等待执行(等待内核调度)</li><li>停止是在收到SIGSTOP等信号时，程序被挂起且不会被调度，直到程序收到SIGCONT信号时，进程再次运行。</li><li>终止态即进程永久的停止。进程终止的原因有以下三种：<ol><li>收到默认行为是终止的信号</li><li>从主程序返回</li><li>调用exit函数</li></ol></li></ul><p>有趣的fork函数</p><p>先看代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;  <span class="comment">// fork出错</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程的程序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process : %d, parent process : %d\n"</span>, getpid(), getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程的程序</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);  <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process %d\n"</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父进程调用fork，完成用户栈到内核栈的切换，产生子进程，父进程返回值为子进程pid，子进程fork返回值为0。(注意这里fork是调用一次，返回两次)。wait(NULL)用于等待所有子进程结束。</p><p>以下有三个要注意的点：</p><ol><li>子进程和父进程有相同的但互相独立的地址空间。每个进程有相同的用户栈，相同的本地变量和全局变量以及相同的代码，对于子进程而言，父进程的PCB只读。当子进程要写的时候，内核会复制新的一页给子进程。</li><li>子进程和父进程并发执行。如果父进程不执行wait，它们之间运行的先后关系是不确定的。</li><li>共享文件。父进程和子进程输出都显示在屏幕上，这是因为子进程继承了父进程输出指向屏幕的stdout文件，</li></ol><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><p>这里有一个僵尸进程的概念。当一个进程终止了但没被回收(内核还有该进程的状态)，该进程就成为了僵尸进程。孤儿进程则是指父进程已经退出而其子进程并未结束。可通过 ps -aux | grep Z 查看僵尸进程。</p><p>对于长时间运行的程序，如shell和服务器，应该总回收它们的孤儿进程，不然会一直消耗内存资源。</p><p>如果父进程没有回收僵尸进程就终止了，这时就遗留了孤儿进程，内核会安排init进程来回收它们(init进程的PID为1, 是系统初始化时由内核创建的，是所有进程的祖先).进程可调用waitpid来等待其子进程的终止。</p><p>如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"children process : %d, father process : %d\n"</span>, getpid(), getppid());  <span class="comment">// 显示父进程id</span></span><br><span class="line">        sleep(<span class="number">5</span>);  <span class="comment">// 子进程在父进程之后结束。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"children process : %d, father process : %d\n"</span>, getpid(), getppid());  <span class="comment">// 显示父进程为1，代表由init回收该子进程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 为了等待子进程输出第一行指令，且父进程比子进程先结束。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent pid : %d, grandparent pid : %d\n"</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程在结束后会发送SIGCHLD信号给父进程。该进程在某段时间内会变成僵尸进程，其不占用内存，但会占用进程号。如果父进程不对结束的子进程进行处理，那么可能会产生一堆僵尸进程。</p><p>父进程可调用wait和waitpid来等待并回收子进程，而如果单纯调用wait函数，会造成父进程阻塞无法执行，解决方法是使用signal函数来接收SIGCHLD信号，signal(SIGCHLD, func)。在func中可以调用wait和waitpid函数来处理回收子进程。</p><p>如下代码可以获取子进程退出的信号(但不做处理)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_child</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"deal child!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">        signal(SIGCHLD,deal_child);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"children process : %d, father process : %d\n"</span>, getpid(), getppid());  <span class="comment">// 显示父进程id</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       sleep(<span class="number">1</span>);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"parent pid : %d, grandparent pid : %d\n"</span>, getpid(), getppid());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait-函数-和-waitpid函数"><a href="#wait-函数-和-waitpid函数" class="headerlink" title="wait 函数 和 waitpid函数"></a>wait 函数 和 waitpid函数</h3><p>wait函数返回-1表示没有子进程，如果清楚掉子进程则返回子进程的pid</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br></pre></td></tr></table></figure><p>在wait函数传入参数后，可获得退出状态。使用宏可以判断具体的退出原因。宏有以下三种。</p><ol><li>正常退出<ul><li>WIFEXITED(status): 显示是否正常退出，非0则表示正常</li><li>WEXITSTATUS(status): 可以获取进程退出的状态(子进程exit 和 return的值)(注意在vfork时，exit和return是有比较大差别的)</li></ul></li><li>异常退出<ul><li>WIFSIGNALED(status): 显示是否异常， 非0表示异常终止</li><li>WTERMSIG(status): 在上一个指令(WIFSIGNAED)返回为真时，返回使进程终止的那个信号编号</li></ul></li><li>暂停<ul><li>WIFSTOPPED(status): 非0表示暂停</li><li>WSTOPSIG(status): 上一条指令(WIFSTOPPED)为真，获取使进程暂停信号的编号</li><li>WIFCONTINUED(status): 为真表示信号暂停后继续执行</li></ul></li></ol><p>waitpid则更加灵活</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* status, <span class="keyword">int</span> options)</span></span></span><br></pre></td></tr></table></figure><p>可以通过等待指定pid的进程来进行有序的清理。pid取值不同表达的含义不同:</p><ol><li>pid = -1, 等待任何子进程的退出，此时waitpid和wait的作用一样</li><li>pid = 0, 回收和调用和当前waitpid一个组的所有子进程</li><li>pid &lt; -1, 表示回收指定进程组(abs(pid))中的所有子进程</li><li>pid &gt; 0, 回收指定pid的子进程</li></ol><p>第三个参数options可以设置以下三种宏(可以通过或来连接):</p><ol><li>WNOHANG: 不阻塞，没有子进程返回0</li><li>WUNTRACED: 返回终止子进程信号的信息</li><li>WCONTINUED: 返回收到SIGCONT而继续执行的子进程信息</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向广搜</title>
      <link href="/2020/08/02/Algorithm/BFS/%E5%8F%8C%E5%90%91%E5%B9%BF%E6%90%9C/"/>
      <url>/2020/08/02/Algorithm/BFS/%E5%8F%8C%E5%90%91%E5%B9%BF%E6%90%9C/</url>
      
        <content type="html"><![CDATA[<p>双向广搜</p><p>建立两个队列，通过比较队列的大小来更换扩展的队列（避免只扩展一个造成超时）。两队列如果能相遇，则说明该问题有解，否则无解。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"><span class="built_in">string</span> ai[N], bi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;&amp;q, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp;da, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp;db, <span class="built_in">string</span> a[], <span class="built_in">string</span> b[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// for(int k=0, sz = size(q);k&lt;sz;k++)&#123;  // 加了速度更快</span></span><br><span class="line">        <span class="built_in">string</span> cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.substr(i,a[j].<span class="built_in">size</span>()) == a[j]) &#123;</span><br><span class="line">                    <span class="built_in">string</span> newa = cur.substr(<span class="number">0</span>, i)+b[j]+cur.substr(i+a[j].<span class="built_in">size</span>());</span><br><span class="line">                    <span class="keyword">if</span>(da.count(newa)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(db.count(newa)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> da[cur]+<span class="number">1</span>+db[newa];</span><br><span class="line">                    &#125;</span><br><span class="line">                    da[newa] = da[cur]+<span class="number">1</span>;</span><br><span class="line">                    q.push(newa);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;qa, qb;</span><br><span class="line">    qa.push(a);</span><br><span class="line">    qb.push(b);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; da, db;</span><br><span class="line">    da[a] = <span class="number">0</span>;</span><br><span class="line">    db[b] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qa.<span class="built_in">size</span>() &amp;&amp; qb.<span class="built_in">size</span>())  &#123;</span><br><span class="line">        <span class="keyword">if</span>(qa.<span class="built_in">size</span>()&lt;=qb.<span class="built_in">size</span>()) t = extend(qa, da, db, ai, bi);</span><br><span class="line">        <span class="keyword">else</span> t = extend(qb, db, da, bi, ai);</span><br><span class="line">        <span class="keyword">if</span>(t&lt;=<span class="number">10</span>) <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ai[cnt]&gt;&gt;bi[cnt]) &#123;cnt++;&#125;</span><br><span class="line">    <span class="keyword">int</span> t = bfs();</span><br><span class="line">    <span class="keyword">if</span>(t&lt;=<span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO ANSWER!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>67. Add Binary</title>
      <link href="/2020/07/20/%E5%8A%9B%E6%89%A3/67.%20Add%20Binary/"/>
      <url>/2020/07/20/%E5%8A%9B%E6%89%A3/67.%20Add%20Binary/</url>
      
        <content type="html"><![CDATA[<p>和上一题是类似的题，通法就是先翻转（低位和高位从0到n), 然后用进位t来加当前的数，模进制更新结果，除以进制，更新进位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">size</span>(a)) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">size</span>(b)) <span class="keyword">return</span> a;</span><br><span class="line">        reverse(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        reverse(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> s = ;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>, n =<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()) ;</span><br><span class="line">        <span class="keyword">while</span>((j&lt;n) || t0) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">size</span>()) t+=(a[j]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(b.<span class="built_in">size</span>()) t+=(b[j]-<span class="string">'0'</span>);</span><br><span class="line">            s+=(<span class="string">'0'</span>+t%<span class="number">2</span>);</span><br><span class="line">            t=<span class="number">2</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One</title>
      <link href="/2020/07/20/%E5%8A%9B%E6%89%A3/66.%20Plus%20One/"/>
      <url>/2020/07/20/%E5%8A%9B%E6%89%A3/66.%20Plus%20One/</url>
      
        <content type="html"><![CDATA[<p>刚开始做暴力建了个数组，之后看了下还有翻转再加的做法，主要是利用push_back加上最后的进位。<br>这个问题还有个更优雅的解法，就是 if else add<br>如果进位，遇到9则变0，遇到其他就返回，最后一位要进位的唯一一种情况是所有数字都是9，这样整个数组变为0，只需要第一位变成1再push_back 0就完成了加法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">size</span>(digits);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i]==<span class="number">9</span>) digits[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                digits[i] = digits[i]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(digits[<span class="number">0</span>]==<span class="number">0</span>) digits[<span class="number">0</span>] = <span class="number">1</span>, digits.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>65. Valid Number</title>
      <link href="/2020/07/20/%E5%8A%9B%E6%89%A3/65.%20Valid%20Number/"/>
      <url>/2020/07/20/%E5%8A%9B%E6%89%A3/65.%20Valid%20Number/</url>
      
        <content type="html"><![CDATA[<p>苦力活，完全是靠报错来更正…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> e = <span class="number">0</span>, sig = <span class="number">0</span>, f=<span class="number">1</span>,p=<span class="number">0</span>, dig=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="built_in">size</span>(s)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="built_in">size</span>(s) &amp;&amp; s[i]==<span class="string">' '</span>) i++;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s[j]==<span class="string">' '</span>) j--;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=i)</span><br><span class="line">            s = s.substr(i, j-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"."</span>|| s==<span class="string">"+"</span>|| s==<span class="string">"-"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f &amp;&amp; (i==<span class="string">'+'</span> || i==<span class="string">'-'</span>)) <span class="keyword">if</span>(!sig&amp;&amp;!dig) sig = <span class="number">1</span>,f=<span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="string">'0'</span> &amp;&amp; i&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                dig = <span class="number">1</span>;</span><br><span class="line">                f = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="string">'e'</span> &amp;&amp; dig) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!e) e=<span class="number">1</span>,sig=<span class="number">0</span>,f=<span class="number">1</span>,dig=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="string">'.'</span> ) &#123;</span><br><span class="line">                f = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!e &amp;&amp; !p) p = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((e &amp;&amp; !dig) || (sig &amp;&amp; !dig)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stuffa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64. Minimum Path Sum</title>
      <link href="/2020/07/20/%E5%8A%9B%E6%89%A3/64.%20Minimum%20Path%20Sum/"/>
      <url>/2020/07/20/%E5%8A%9B%E6%89%A3/64.%20Minimum%20Path%20Sum/</url>
      
        <content type="html"><![CDATA[<p>本来写的是二维dp，看到有个更好的一维做法<br>因为状态更新是 dp[i][j] = min(dp[i-1][j], dp[i][j-1])+g[i][j]，j是上一个状态的，j-1是当前状态。而正好更新为一维后，j-1会在j之前进行计算，在算当前j的时候，用到的dp[j]还是之前的j。因此可以转化为一维。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">size</span>(g), m = <span class="built_in">size</span>(g[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(m,INT_MAX);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] += g[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j<span class="number">-1</span>], dp[j])+g[i][j];</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>63. Unique Paths II</title>
      <link href="/2020/07/20/%E5%8A%9B%E6%89%A3/63.%20Unique%20Paths%20II/"/>
      <url>/2020/07/20/%E5%8A%9B%E6%89%A3/63.%20Unique%20Paths%20II/</url>
      
        <content type="html"><![CDATA[<p>看了这题想起了卡特兰数，去复习了一下。卡特兰数模型是可以等价为一个0, 1的序列(前缀0的个数大于等于1的个数)，这样在2n步后，每个非目标值都可等价为往上或往右走了n-1步。因此，到目标点实际的合法次数为$C^{n}<em>{2n}-C^{n-1}</em>{2n} = C^n_{2n}/(n+1)$。<br>而不同路径这个题就比较暴力了，实际是从n+m-2步中(起始为0，终点为n-1+m-1，走的步数为n-1+m-1)选取n-1步。<br>设置障碍实际就是增加一个非法状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">size</span>(o), m = <span class="built_in">size</span>(o[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!i &amp;&amp; !j &amp;&amp; !o[i][j]) dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!o[i][j])&#123; </span><br><span class="line">                        <span class="keyword">if</span>(i&gt;=<span class="number">1</span>)dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                        <span class="keyword">if</span>(j&gt;=<span class="number">1</span>)dp[i][j] += dp[i][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1513. Number of Substrings With Only 1s</title>
      <link href="/2020/07/18/%E5%8A%9B%E6%89%A3/1513.%20Number%20of%20Substrings%20With%20Only%201s/"/>
      <url>/2020/07/18/%E5%8A%9B%E6%89%A3/1513.%20Number%20of%20Substrings%20With%20Only%201s/</url>
      
        <content type="html"><![CDATA[<p>Simple if else and add method</p><a id="more"></a><p>第一版自己写的太复杂，其实这就是if else 判断的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="string">'1'</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res = (res+(((cnt+<span class="number">1</span>)*cnt))/<span class="number">2</span>)%MOD;</span><br><span class="line">                cnt  = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt) res = (res+((cnt+<span class="number">1</span>)*cnt)/<span class="number">2</span>)%MOD;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> if else add </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>61. Rotate List</title>
      <link href="/2020/07/18/%E5%8A%9B%E6%89%A3/61.%20Rotate%20List/"/>
      <url>/2020/07/18/%E5%8A%9B%E6%89%A3/61.%20Rotate%20List/</url>
      
        <content type="html"><![CDATA[<p>找链表的第(n-k)个位置</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* h, ListNode* hh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h==<span class="literal">NULL</span> || h-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> h;</span><br><span class="line">        ListNode *pre = hh, *cur = h, *nxt = h;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span> || !k) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        ListNode* h = head,*pre = h;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k%cnt==<span class="number">0</span>) <span class="keyword">return</span> h;</span><br><span class="line">        k=k%cnt;</span><br><span class="line">        ListNode* nh = h;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt-k<span class="number">-1</span>;i++) nh = nh-&gt;next;</span><br><span class="line">        ListNode* new_h = nh-&gt;next;</span><br><span class="line">        nh-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;next = h;</span><br><span class="line">        <span class="keyword">return</span> new_h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>60. Permutation Sequence</title>
      <link href="/2020/07/18/%E5%8A%9B%E6%89%A3/60.%20Permutation%20Sequence/"/>
      <url>/2020/07/18/%E5%8A%9B%E6%89%A3/60.%20Permutation%20Sequence/</url>
      
        <content type="html"><![CDATA[<p>cantor逆展开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> fact(n<span class="number">-1</span>)*n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(n+<span class="number">1</span>);</span><br><span class="line">        k = k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=n<span class="number">-1</span>;t&gt;=<span class="number">0</span>;t--) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, cf = fact(t);</span><br><span class="line">            <span class="keyword">int</span> cur = k/cf;</span><br><span class="line">            k = k%cf;</span><br><span class="line">            <span class="keyword">for</span>(m=<span class="number">1</span>;m&lt;=n;m++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[m]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!cur) <span class="keyword">break</span>;</span><br><span class="line">                    cur--;<span class="comment">// 往后走</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[m] = <span class="number">1</span>;</span><br><span class="line">            res+=(<span class="string">'0'</span>+m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> permutation </tag>
            
            <tag> cantor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>59. Spiral Matrix II</title>
      <link href="/2020/07/18/%E5%8A%9B%E6%89%A3/59.%20Spiral%20Matrix%20II/"/>
      <url>/2020/07/18/%E5%8A%9B%E6%89%A3/59.%20Spiral%20Matrix%20II/</url>
      
        <content type="html"><![CDATA[<p>和第一道螺旋矩阵几乎一样</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generateMatrix</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> di[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dj[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">st</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> num = n*n, cx = <span class="number">0</span>, cy = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*n;i++) &#123;</span><br><span class="line">            res[cx][cy] = i;</span><br><span class="line">            st[cx][cy] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> a = cx+di[k], b = cy+dj[k];</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">0</span> || b&lt;<span class="number">0</span> || a&gt;=n || b&gt;=n || st[a][b]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">                k = k%<span class="number">4</span>;</span><br><span class="line">                a = cx+di[k], b = cy+dj[k];</span><br><span class="line">            &#125;</span><br><span class="line">            cx = a, cy = b;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matrix </tag>
            
            <tag> direction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58. Length of Last Word</title>
      <link href="/2020/07/18/%E5%8A%9B%E6%89%A3/58.%20Length%20of%20Last%20Word/"/>
      <url>/2020/07/18/%E5%8A%9B%E6%89%A3/58.%20Length%20of%20Last%20Word/</url>
      
        <content type="html"><![CDATA[<p>string的简单题</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">​```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>57. Insert Interval</title>
      <link href="/2020/07/18/%E5%8A%9B%E6%89%A3/57.%20Insert%20Interval/"/>
      <url>/2020/07/18/%E5%8A%9B%E6%89%A3/57.%20Insert%20Interval/</url>
      
        <content type="html"><![CDATA[<p>Simple if else and merge</p><a id="more"></a><p>刚开始也想复杂了，实际这个问题和simple if else add是一类问题。找到问题的关键状态(中间状态)，其余情况则是开始和结束状态，在结束状态的时候计算关键状态的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">bool</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:a) &#123;</span><br><span class="line">            <span class="comment">//与目标无关的状态</span></span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">0</span>]&gt;i[<span class="number">1</span>]) &#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b[<span class="number">1</span>]&lt;i[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!st) &#123;</span><br><span class="line">                    st = <span class="number">1</span>;</span><br><span class="line">                    res.push_back(b);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//目标(合并区间)</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                b[<span class="number">0</span>] = <span class="built_in">min</span>(b[<span class="number">0</span>], i[<span class="number">0</span>]);</span><br><span class="line">                b[<span class="number">1</span>] = <span class="built_in">max</span>(b[<span class="number">1</span>], i[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st) res.push_back(b);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> if else add </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/2020/07/16/%E5%8A%9B%E6%89%A3/56.%20Merge%20Intervals/"/>
      <url>/2020/07/16/%E5%8A%9B%E6%89%A3/56.%20Merge%20Intervals/</url>
      
        <content type="html"><![CDATA[<p>简单的区间合并问题</p><a id="more"></a><p>有一个情况是前一个区间左边的右端点大于该区间右边的右端点，因此要取一个max</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!intervals.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>]&lt;b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> prel = intervals[<span class="number">0</span>][<span class="number">0</span>], prer = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:intervals) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i[0] &lt;&lt;" " &lt;&lt;i[1] &lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(i[<span class="number">0</span>]&lt;=prer) prer = <span class="built_in">max</span>(prer, i[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(&#123;prel, prer&#125;);</span><br><span class="line">                prel = i[<span class="number">0</span>];</span><br><span class="line">                prer = i[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(&#123;prel, prer&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2020/07/16/%E5%8A%9B%E6%89%A3/55.%20Jump%20Game/"/>
      <url>/2020/07/16/%E5%8A%9B%E6%89%A3/55.%20Jump%20Game/</url>
      
        <content type="html"><![CDATA[<p>这其实可看作状态转移的问题，看能否转移到最终态</p><a id="more"></a><p>设置右边界，要达到了右边界才能往后面跳</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">size</span>(nums),r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r&gt;=i)</span><br><span class="line">                r = <span class="built_in">max</span>(r, i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r&gt;=n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simple NLP proj</title>
      <link href="/2020/07/16/NLP/simpleNLPProj/"/>
      <url>/2020/07/16/NLP/simpleNLPProj/</url>
      
        <content type="html"><![CDATA[<p>根据专家描述寻找一篇文章的主旨句。</p><a id="more"></a><p>方法是直接根据经验生成词表，如this paper, we conduct等，找出含有这些词的句子。</p><p>对于每个词都用nltk中的WordnetLemmatizer中的lemmatize方法，还原其原型</p><p>分句用的方法是nltk的sent_tokenize方法，将词表中的每个词和每个句子中的每个词进行比对，最后得到结果。</p><p>最后找出的主旨句占25/50。大部分应该是正确的, 少部分误找了，有的文章可能本来就没有主旨句或主旨句不明显。做的还是有点粗糙，之后再查看网上是否有比较完备的方法。</p><p>学到的方法：</p><ol><li><p>将list和index转为dict: dic = zip(list, range(len(list)))</p></li><li><p>lower, islower等判断是否是小写</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. Spiral Matrix</title>
      <link href="/2020/07/16/%E5%8A%9B%E6%89%A3/54.%20Spiral%20Matrix/"/>
      <url>/2020/07/16/%E5%8A%9B%E6%89%A3/54.%20Spiral%20Matrix/</url>
      
        <content type="html"><![CDATA[<p>方向数组</p><a id="more"></a><p>每次遇到这种问题容易陷入细节想的比较复杂。自己写的时候总是想保证每一步都在控制之内，而其实如果允许它的搜索超出范围，并在超出范围时及时更正，可以更好的解决，解法也会更简洁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((x==n<span class="number">-1</span>||x==<span class="number">0</span>) &amp;&amp; (y==m<span class="number">-1</span> || y==<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!matrix.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">int</span> di[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;, dj[] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>, i = <span class="number">0</span>, curx=<span class="number">0</span>,cury=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">size</span>(matrix), m = <span class="built_in">size</span>(matrix[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> sz = n*m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;st(sz, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(j&lt;sz) &#123;</span><br><span class="line">            st[curx*m+cury] = <span class="number">1</span>;</span><br><span class="line">            res.push_back(matrix[curx][cury]);</span><br><span class="line">            <span class="keyword">int</span> a = curx+di[i], b = cury+dj[i];</span><br><span class="line">            <span class="comment">//probe</span></span><br><span class="line">            <span class="comment">//如果超过范围，或已经到达边界，则重新更正</span></span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;=n || b&lt;<span class="number">0</span> || b&gt;=m || st[a*m+b]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">4</span>) i=<span class="number">0</span>;</span><br><span class="line">                a = curx+di[i], b = cury+dj[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curx = a, cury = b;</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方向搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/2020/07/15/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2020/07/15/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>应用层</p><a id="more"></a><h2 id="应用层协议-Http-SMTP"><a href="#应用层协议-Http-SMTP" class="headerlink" title="应用层协议(Http, SMTP)"></a>应用层协议(Http, SMTP)</h2><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><img src="/2020/07/15/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20200715232155129.png" alt="image-20200715232155129"></p><p>报文比较重要的部分是第一行定义了要做什么，去哪做，以及做事的规则</p><p><img src="/2020/07/15/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20200715232904052.png" alt="image-20200715232904052"></p><p>更为通用的部分如上图。其中entity body是post（填写表单时）要添加的方法。</p><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><img src="/2020/07/15/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20200715233123820.png" alt="image-20200715233123820"></p><p>重要的部分是查看返回的状态码、last-modified time(文件最后一次变动的时间)、data(返回的数据)</p><h3 id="Http1-0-与-Http1-1的对比"><a href="#Http1-0-与-Http1-1的对比" class="headerlink" title="Http1.0 与 Http1.1的对比"></a>Http1.0 与 Http1.1的对比</h3><p><img src="/2020/07/15/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20200715233103087.png" alt="image-20200715233103087"></p><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>cookie主要用途是通过服务器认证用户身份</p><p>cookie技术的组成如下：</p><ol><li>Http请求报文有cookie行</li><li>Http响应报文有cookie行</li><li>用户有cookie文件，由浏览器管理</li><li>Web端有cookie数据库</li></ol><p><img src="/2020/07/15/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20200715233518175.png" alt="image-20200715233518175"></p><p>Web端对每个用户有唯一识别码，并可通过cookie跟踪用户活动（用户浏览页面会向服务器发送请求)。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53 Maximum Subarray</title>
      <link href="/2020/07/12/%E5%8A%9B%E6%89%A3/53%20Maximum%20Subarray/"/>
      <url>/2020/07/12/%E5%8A%9B%E6%89%A3/53%20Maximum%20Subarray/</url>
      
        <content type="html"><![CDATA[<p>一共两种做法，一个是在线处理，一个是分治。</p><a id="more"></a><p>在线处理主要考虑是否添加之前计算过的元素，遍历过程中，它存储的是在[0: i]之前的最大值，如果之前的值是小于0的，那它必然是对之后的和没有增益，应该丢弃。而如果之前的和是大于0的，对当前一定是有增益的，此时要加在当前元素上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">size</span>(nums), res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, t = INT_MIN;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t = nums[i];</span><br><span class="line">            <span class="keyword">else</span> t+=nums[i];</span><br><span class="line">            res = <span class="built_in">max</span>(res, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分治法的主要难点在于如何处理中间的部分，即横跨mid的那一部分。需要分别从左到右、从右到左连续扫描左边和右边的区间，记录出两个区间连续的lmx和rmx。此时再比较三个部分的最值{(l,mid), (l1,r1), (mid+1, r)}。这种做法时间复杂度为nlog(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mxsum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> n[l];</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lm = mxsum(l,mid,n);</span><br><span class="line">        <span class="keyword">int</span> rm = mxsum(mid+<span class="number">1</span>,r,n);</span><br><span class="line">        <span class="keyword">int</span> lmx=INT_MIN, rmx=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid, tmp=<span class="number">0</span>;i&gt;=l;i--) &#123;</span><br><span class="line">            tmp += n[i];</span><br><span class="line">            lmx = <span class="built_in">max</span>(lmx, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>, tmp = <span class="number">0</span>;i&lt;=r;i++) &#123;</span><br><span class="line">            tmp += n[i];</span><br><span class="line">            rmx = <span class="built_in">max</span>(rmx, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(lm,rm), rmx+lmx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">size</span>(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mxsum(<span class="number">0</span>, n<span class="number">-1</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Segment tree basis</title>
      <link href="/2020/07/12/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91/Segment%20Tree%20Basis/"/>
      <url>/2020/07/12/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91/Segment%20Tree%20Basis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3 Longest Substring Without Repeating Chars</title>
      <link href="/2020/06/01/%E5%8A%9B%E6%89%A3/3%20Longest%20Substring%20Without%20Repeating%20Chars/"/>
      <url>/2020/06/01/%E5%8A%9B%E6%89%A3/3%20Longest%20Substring%20Without%20Repeating%20Chars/</url>
      
        <content type="html"><![CDATA[<p>双指针+map，注意这里符号可能不是只限于a,b,c这类字符，也可能是空格，因此<del>map不能改为数组</del> ( 打脸,  这里char其实根本不用转换为int。用数组的化，数组大小就开ascii码的最大值 256</p><a id="more"></a><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, h = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!umap.count(s[i]-<span class="string">'a'</span>) || umap[s[i]-<span class="string">'a'</span>]&lt;h)</span><br><span class="line">                t = i, len = <span class="built_in">max</span>(len, t-h+<span class="number">1</span>);            </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len = <span class="built_in">max</span>(len, t-h+<span class="number">1</span>);</span><br><span class="line">                h = umap[s[i]-<span class="string">'a'</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[s[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, h = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">256</span>];</span><br><span class="line">        <span class="built_in">memset</span>(count,<span class="number">-1</span>,<span class="keyword">sizeof</span> count);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[s[i]] ==<span class="number">-1</span> || count[s[i]]&lt;h)</span><br><span class="line">                t = i, len = <span class="built_in">max</span>(len, t-h+<span class="number">1</span>);            </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len = <span class="built_in">max</span>(len, t-h+<span class="number">1</span>);</span><br><span class="line">                h = count[s[i]]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3:"></a>Solution 3:</h3><p>对solution2的改进(<del>虽然不知道为啥快了</del>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">256</span>];</span><br><span class="line">        <span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="keyword">sizeof</span> count);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">            count[s[i]] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(count[s[i]]&gt;<span class="number">1</span>) count[s[h++]]--;</span><br><span class="line">            len = <span class="built_in">max</span>(len, i-h+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map, two pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2  Add Two Numbers</title>
      <link href="/2020/06/01/%E5%8A%9B%E6%89%A3/2%20Add%20Two%20Numbers/"/>
      <url>/2020/06/01/%E5%8A%9B%E6%89%A3/2%20Add%20Two%20Numbers/</url>
      
        <content type="html"><![CDATA[<p>Linklist 基本题</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* res &#x3D; new ListNode(0);</span><br><span class="line">        ListNode* head &#x3D; res;</span><br><span class="line">        int t &#x3D; 0;</span><br><span class="line">        while(l1 &amp;&amp; l2)&#123;</span><br><span class="line"></span><br><span class="line">            res-&gt;next &#x3D; new ListNode((l1-&gt;val+l2-&gt;val+t)%10);</span><br><span class="line">            t &#x3D; (l1-&gt;val+l2-&gt;val+t)&#x2F;10;</span><br><span class="line">            l1 &#x3D; l1-&gt;next;</span><br><span class="line">            l2 &#x3D; l2-&gt;next;</span><br><span class="line">            res &#x3D; res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2) l1 &#x3D; l2; </span><br><span class="line">        while(l1) &#123;</span><br><span class="line">            res-&gt;next &#x3D; new ListNode((l1-&gt;val+t)%10);</span><br><span class="line">            t &#x3D; (l1-&gt;val+t)&#x2F;10;</span><br><span class="line">            l1 &#x3D; l1-&gt;next;</span><br><span class="line">            res &#x3D; res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(t) res-&gt;next &#x3D; new ListNode(t);</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1 Two sum</title>
      <link href="/2020/06/01/%E5%8A%9B%E6%89%A3/1%20Two%20Sum/"/>
      <url>/2020/06/01/%E5%8A%9B%E6%89%A3/1%20Two%20Sum/</url>
      
        <content type="html"><![CDATA[<p>STL容器使用</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;nums.<span class="built_in">size</span>();k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!umap.count(target-nums[k])) umap[nums[k]] = k;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;umap[target-nums[k], k]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Nim game</title>
      <link href="/2020/05/15/Algorithm/%E5%8D%9A%E5%BC%88%E8%AE%BA/Nim1/"/>
      <url>/2020/05/15/Algorithm/%E5%8D%9A%E5%BC%88%E8%AE%BA/Nim1/</url>
      
        <content type="html"><![CDATA[<p>Nim游戏是指两名选手进行一个游戏，每次每个选手可以进行一种操作，直至某个选手无法进行操作为止，此时无法进行操作的选手失败。这次讨论的是最基本的Nim游戏：n堆石子里拿石子，每次每人可以在一堆中拿一部分或全部拿完，先手是否有必胜策略。<br>此游戏的关键是找到必胜态和必败态。必胜态即$ a_1\oplus a_2\oplus a_3\oplus a_4\cdots\oplus a_n=x, x\neq0$, 必败态即为$a_1\oplus a_2\oplus  a_3\oplus a_4\cdots\oplus a_n=0$, 具体证明即包含x的为1的最高位对应左式中的$a_i$, $a_i-a_i\oplus x&gt;0$, 于是从$a_i$中拿走$a_i-a_i\oplus x$后，还剩$a_i\oplus x$，于是 $ a_1\oplus a_2\oplus a_3\oplus a_4\cdots\oplus a_n\oplus x=x\oplus x=0$，此时为必败态。而必败态的证明较为简单。在了解原理后，此题代码也较容易</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        res^=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Principle of inclusion-exclusion</title>
      <link href="/2020/05/15/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Principle%20of%20inclusion-exclusion/"/>
      <url>/2020/05/15/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Principle%20of%20inclusion-exclusion/</url>
      
        <content type="html"><![CDATA[<p>最基本的容斥原理，主要需要用到对韦恩图的理解和划分集合的子集。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;primes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        ll t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span>&lt;&lt;j &amp; i) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                t = t*primes[j];</span><br><span class="line">                <span class="keyword">if</span>(t&gt;n)&#123;</span><br><span class="line">                    t = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">2</span>) res+=n/t;</span><br><span class="line">            <span class="keyword">else</span> res-=n/t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Catalan number</title>
      <link href="/2020/05/14/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Catalan%20Number/"/>
      <url>/2020/05/14/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Catalan%20Number/</url>
      
        <content type="html"><![CDATA[<p>卡特兰数，还有很多应用的情况需要总结。这里就先列出其表达式: $\frac{C^n_{2n}}{n+1}$，计算就用组合数的计算和逆元即可。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>, MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll fact[<span class="number">2</span>*N],infact[N+<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fast_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%MOD;</span><br><span class="line">        a = (ll) a*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// init();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) res = res*i%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res = res*fast_pow(i,MOD<span class="number">-2</span>)%MOD;</span><br><span class="line">    res = res*fast_pow(n+<span class="number">1</span>,MOD<span class="number">-2</span>)%MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Combination number (high precision)</title>
      <link href="/2020/05/14/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Combination%20number4/"/>
      <url>/2020/05/14/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Combination%20number4/</url>
      
        <content type="html"><![CDATA[<p>高精度求组合数，借助公式 $C^b_a = \frac{a!}{(a-b)!b!}$, 可以考虑将a!, b!, (a-b)!, 分解为质因数的乘积，这样只需将这些质因数用高精度乘法相乘即可。质因数可用线性素数筛选出，选出后，计算a!, b!, (a-b)!中包含p的次数。对一个数n而言，n!包含其质因数p的次数为$n/p+n/p^2+n/p^3+…$。最后从a!将b!, (a-b)!中的质因数除去。用高精度乘法计算剩余的质因数乘积即可。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> primes[N], sum[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=a;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;primes[j]&lt;=a/i;j++) &#123;</span><br><span class="line">            st[primes[j]*i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1*2*3*···*a, 中共包含p的多少次</span></span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        res += a/p;</span><br><span class="line">        a/=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;A, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        res.push_back((A[i]*p+t)%<span class="number">10</span>);</span><br><span class="line">        t = (A[i]*p+t)/<span class="number">10</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; t &lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        res.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    get_primes(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">get</span>(a,primes[i])-<span class="built_in">get</span>(a-b,primes[i])-<span class="built_in">get</span>(b,primes[i]);</span><br><span class="line">        sum[primes[i]] = num;</span><br><span class="line">        <span class="comment">// cout&lt;&lt; num &lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">    res.push_back(<span class="number">1</span>);<span class="comment">//大数必须要先赋初值，不然sz为0，无法完成高精度运算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sum[primes[i]];j++) &#123;</span><br><span class="line">            res = mul(res, primes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Combination number 3 (lucas)</title>
      <link href="/2020/05/13/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Combination%20number3/"/>
      <url>/2020/05/13/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Combination%20number3/</url>
      
        <content type="html"><![CDATA[<p>lucas 算法，可以在a, b值比较大的情况下求得组合数的值，其中p为小于1e5的质数。运用的公式为$C_a^b = C_{a\ mod\ p}^{b\ mod\ p} * C_{a / p}^{b / p}$，等式的后一项可以递归求解。如果组合数已经预处理后(fact,infact均存在)，算法时间复杂度为$log_pn$。现在这个写法复杂度为$ plogn$  </p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%p;</span><br><span class="line">        a = (ll) a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a,j=<span class="number">1</span>;j&lt;=b;i--,j++) &#123;</span><br><span class="line">        res = res*i%p;</span><br><span class="line">        res = res*quick_pow(j,p<span class="number">-2</span>,p)%p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lucas</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;p &amp;&amp; b&lt;p) <span class="keyword">return</span> C(a,b,p);</span><br><span class="line">    <span class="keyword">return</span> (ll) C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        ll a, b, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;a, &amp;b, &amp;p);</span><br><span class="line">        <span class="comment">// lucas(a, b, p)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, lucas(a,b,p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Combination number 2</title>
      <link href="/2020/05/13/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Combination%20number2/"/>
      <url>/2020/05/13/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Combination%20number2/</url>
      
        <content type="html"><![CDATA[<p>数据复杂度在1e10时，不能再使用此前打表迭代的做法。比较直观的想法是从表达式入手，$ C_a^b = \frac{a!}{(a-b)! * b!} $, 用两个表来记录 fact的值，和逆元fact的值即可将时间复杂度变为NlogN。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>,MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fac[N], infac[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fast_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)a*fast_pow(a,b<span class="number">-1</span>)%MOD;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = fast_pow(a,b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (tmp*tmp)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>,infac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++)&#123;</span><br><span class="line">        fac[i] = (<span class="keyword">long</span> <span class="keyword">long</span>)fac[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">        infac[i] = (<span class="keyword">long</span> <span class="keyword">long</span>)infac[i<span class="number">-1</span>]*fast_pow(i, MOD<span class="number">-2</span>)%MOD;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)fac[a]*infac[b]%MOD*infac[a-b]%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Combination number1</title>
      <link href="/2020/05/12/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Combination%20number1/"/>
      <url>/2020/05/12/Algorithm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/Combination%20number1/</url>
      
        <content type="html"><![CDATA[<p>当求组合数的预处理时间复杂度在1e6左右时，可以用类似迭代的方式求得$ C_a^b $的值，用到的迭代公式是$ C_i^j = C_{i-1}^j+C_{i-1}^{j-1}  $，即根据j中是否包含某点来确定组合数的值。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>, MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> c[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2000</span>;i++) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">            c[i][j] = (c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,c[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear congruence equation</title>
      <link href="/2020/05/12/Algorithm/%E6%95%B0%E8%AE%BA/Linear%20congruence%20equation/"/>
      <url>/2020/05/12/Algorithm/%E6%95%B0%E8%AE%BA/Linear%20congruence%20equation/</url>
      
        <content type="html"><![CDATA[<p>线性同余方程，即满足：$a_i * x_i \equiv b_i (mod\ m_i)$。其实可看为扩展欧几里得算法的变体。扩展欧几里得算法解决的是$a * x + b * y = gcd(a,b)$, 而这个问题中b必然为gcd(a, m)的倍数，由此可用扩展欧几里得算法求得gcd(a,b)对应的x，再scale $ b / gcd(a, b) $。注意是否需要满足在int范围内。 </p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x = <span class="number">1</span>, y = <span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = extgcd(b, a%b, y, x);</span><br><span class="line">        y -= a/b*x;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,m,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> d = extgcd(a,m,x,y);</span><br><span class="line">        <span class="keyword">if</span>(b%d==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)x*(b/d)%m);&#125; <span class="comment">//模m是为了在保证在int范围内，同时确保方程有解</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Extended euclidean algorithm</title>
      <link href="/2020/05/12/Algorithm/%E6%95%B0%E8%AE%BA/Extended%20euclidean%20algorithm/"/>
      <url>/2020/05/12/Algorithm/%E6%95%B0%E8%AE%BA/Extended%20euclidean%20algorithm/</url>
      
        <content type="html"><![CDATA[<p>1) 裴蜀定理</p><p>​        对任意整数a, b，一定存在整数x, y，使得：$ax + by = gcd(a, b)$, 一定存在非零整数x, y，ax+by必为其最大公因数的倍数。</p><p>2) 扩展欧几里得算法</p><p>​        在欧几里得算法的基础上求得满足：$ax+by = gcd(a, b)$的一组(x, y)。</p><p>其核心思想是利用欧几里得原理：$ax+by = gcd(a,b) = gcd(b,a % b) = bx’+(a-a/b*b)y’ = ay’+b(x’-a/b * y’)’$，对应系数相等，可得: $x = y’, y = (x’-a/b * y’)$，此即第一种做法。<br>第二种做法是考虑 $ b * y+a%bx = ax + b(y-a/bx) = gcd(a, b) $，对应项系数相等可得：y = y-a/bx，此为第二种做法。其实在第一种做法中，如果考虑递归时交换x, y，此时返回的x 实则是 传入递归的y，y为传入递归的x，故可看作坐标变换，因此y还需减去$a/b * x$，这样代码形式也和第二种做法一样了。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123; y = <span class="number">0</span>, x = <span class="number">1</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1;</span><br><span class="line">        <span class="keyword">int</span> d = extgcd(b,a%b,x1,y1);</span><br><span class="line">        x = y1;</span><br><span class="line">        y = x1-a/b*y1;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123; y = <span class="number">0</span>, x = <span class="number">1</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = extgcd(b,a%b,x,y);</span><br><span class="line">        y -= a/b*b*x</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a, &amp;b);</span><br><span class="line">        extgcd(a,b,x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mod inverse</title>
      <link href="/2020/05/12/Algorithm/%E6%95%B0%E8%AE%BA/Mod%20Inverse/"/>
      <url>/2020/05/12/Algorithm/%E6%95%B0%E8%AE%BA/Mod%20Inverse/</url>
      
        <content type="html"><![CDATA[<p>逆元是模数除法的一个解决方案</p><p>1) 剩余类</p><p>将对模数m余数相同的数记为一类，共有m类（{0,1,…,m-1}）</p><p>2) 完全剩余系</p><p>从模m的每个剩余类取各一个数，得到m个数的集合，叫做模m的完全剩余系</p><p>引理：若$ a_1, a_2, \cdots, a_m $为模m的完全剩余系A1，b与m互质，则$ b * a_1, b * a_2, \cdots, b * a_m $亦是m的完全剩余系A2。</p><p>证明：若存在 $b * a_i \equiv b * a_j (mod\ m)$，则$ a_i \equiv a_j (mod\ m) $，又$a_i, a_j$均为m完全剩余系中的元素，故A2中不存在同一个剩余类中的2个元素。因此A2为m的完全剩余系。</p><a id="more"></a><p>3) 逆元</p><p>设 c 是 b 的逆元，则有$b * c\equiv 1(mod\ m)$，b存在乘法逆元的充要条件是 b 与 m互质。</p><p>推论：(a/b) mod m = a/b * 1 mod m = a/b * b * c mod m = a * c mod m。故$ a/b \equiv a*(b的逆元) mod\ m$</p><p>4) 费马小引理的证明</p><p>费马小引理：a是不能被质数p整除的正整数，则有$a^{p-1} \equiv 1(mod p)$</p><p>推论：此时，a的逆元为$a^{p-2}$</p><p>证明：p的完全剩余系为：$1, 2, \cdots, p-1$，由于a, p互质，因此有 $a * 1, a * 2, \cdots, a * (p-1)$亦是p的完全剩余系，由此有$ 1 * 2 * \cdots * (p-1) = a * 1 * a * 2 * \cdots * a * (p-1) $ ，可以得到 $ a^{p-1} \equiv 1\ mod\ p$</p><p>由费马小引理结论可知，用快速幂可以快速求得一个数的逆元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?(gcd(b,a%b)):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (<span class="keyword">long</span> <span class="keyword">long</span>) a*res%p;  </span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>)a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    quick_pow(b, p<span class="number">-2</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> b, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;b, &amp;p);</span><br><span class="line">        <span class="keyword">if</span>(b%p!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,inv(b, p));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此前的求约数和问题亦可用逆元的方法来解决（若直接除以p-1会出错）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">fact</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> (a%MOD*fact(a,n<span class="number">-1</span>)%MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%MOD;</span><br><span class="line">        a = (LL) a*a%MOD;</span><br><span class="line">    </span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;primes;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++)</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i,primes[i]++;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>) primes[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime:primes) res=(res*(fact(prime.x,prime.y+<span class="number">1</span>)<span class="number">-1</span>)%MOD*quick_pow(prime.x<span class="number">-1</span>, MOD<span class="number">-2</span>)%MOD)%MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fast pow</title>
      <link href="/2020/05/11/Algorithm/%E6%95%B0%E8%AE%BA/Fast%20Pow/"/>
      <url>/2020/05/11/Algorithm/%E6%95%B0%E8%AE%BA/Fast%20Pow/</url>
      
        <content type="html"><![CDATA[<p>快速幂，有迭代和递归两种写法，log n复杂度，迭代方法的速度会更快</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fast_pos</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (<span class="keyword">long</span> <span class="keyword">long</span>)a*res%p;</span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>) a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fast_pos</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) <span class="keyword">return</span> (a*fast_pos(a,b<span class="number">-1</span>,p))%p;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = fast_pos(a,b&gt;&gt;<span class="number">1</span>,p);</span><br><span class="line">    <span class="keyword">return</span> (tmp*tmp)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,fast_pos(a,b,p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler&#39;s sifter</title>
      <link href="/2020/05/11/Algorithm/%E6%95%B0%E8%AE%BA/Euler&#39;s%20sifter/"/>
      <url>/2020/05/11/Algorithm/%E6%95%B0%E8%AE%BA/Euler&#39;s%20sifter/</url>
      
        <content type="html"><![CDATA[<p>这里是用筛法求1到n每个数的欧拉函数之和。可以直接用线性素数筛的模板，需要注意的就是在筛数的时候，如果是质数，欧拉函数的值为p-1，如果不是质数，在筛数时，若primes[j]是数a的最小质因数且小于当前的i最小质因数的值，则用$p[j] * \phi(i) * \frac{p[j]-1}{p[j]}=i * (p[j]-1)$，若p[j]是i中最小质因数，则用p[j]*phi(i)来更新a的欧拉函数</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="function">LL <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    LL phi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="number">0</span>) primes[cnt++] = i,st[i]=i<span class="number">-1</span>,phi+=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; primes[j]&lt;=n/i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                st[i*primes[j]] = primes[j]*st[i];</span><br><span class="line">                phi += st[i*primes[j]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st[i*primes[j]] = st[i]*(primes[j]<span class="number">-1</span>);</span><br><span class="line">                phi += st[i*primes[j]];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> phi+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,get_eulers(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler&#39;s totient function</title>
      <link href="/2020/05/11/Algorithm/%E6%95%B0%E8%AE%BA/Euler&#39;s%20totient%20function/"/>
      <url>/2020/05/11/Algorithm/%E6%95%B0%E8%AE%BA/Euler&#39;s%20totient%20function/</url>
      
        <content type="html"><![CDATA[<p>求一个数在1–N中互质的数，如果用gcd硬做会超时。借助欧拉函数可得到结论，主要的思想是对于任一数 $a=p_1^{k_1} * p_2^{k_2} * \cdots *  p_m^{k_m}$ 而言，其在1–a中同时被a和p1整除的数的个数为 a/p1，被a和p2同时整除的数为a/p2，…，这些数都需要被去除，但根据容斥原理乘积次数为偶数次的项被重复去除了，乘积为奇数次的项需要再次去除。由此可得到欧拉函数的表达式：</p><p>$$ \phi(x) = x * (1-\frac{1}{p_1})(1-\frac{1}{p_2}) * \cdots * (1-\frac{1}{p_m}) $$</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">int</span> res = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">                res =res/i*(i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>) res = res/x*(x<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euclidean algorithm(gcd)</title>
      <link href="/2020/05/10/Algorithm/%E6%95%B0%E8%AE%BA/Euclidean%20algorithm/"/>
      <url>/2020/05/10/Algorithm/%E6%95%B0%E8%AE%BA/Euclidean%20algorithm/</url>
      
        <content type="html"><![CDATA[<p>gcd算法(greatest common divisor)，也称辗转相除算法或欧几里得算法，原理的证明比较简单，假设a,b最大公约数为d，则 d|a, d|b，且d|(xa+yb)，又由于a%b = a-a/b*b = a+yb，因此 d = (b,a%b)。由此得证。需注意这里a，b不用分大小，因gcd(a,b) = gcd(b,a)。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,gcd(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sum of factors</title>
      <link href="/2020/05/10/Algorithm/%E6%95%B0%E8%AE%BA/Sum%20of%20factors/"/>
      <url>/2020/05/10/Algorithm/%E6%95%B0%E8%AE%BA/Sum%20of%20factors/</url>
      
        <content type="html"><![CDATA[<p>求所有约数的和，用快速幂不知道咋有问题，得用等比数列的递推求和公式: t = p*t+1。求约数的和与求所有约数个数有相通之处，这里需要注意取模的地方。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xx first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> yy second</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">fact</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    LL tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span> == <span class="number">1</span>) ans= ans*tmp%MOD;</span><br><span class="line">        tmp = tmp*tmp%MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;LL,LL&gt;primes;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++)</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i,primes[i]++;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>) primes[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1L</span>L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime:primes) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = prime.second, p = prime.first;</span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a--) t = (p*t+<span class="number">1</span>)%MOD;</span><br><span class="line">        res = res*t%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Number of factors</title>
      <link href="/2020/05/10/Algorithm/%E6%95%B0%E8%AE%BA/Number%20of%20factors/"/>
      <url>/2020/05/10/Algorithm/%E6%95%B0%E8%AE%BA/Number%20of%20factors/</url>
      
        <content type="html"><![CDATA[<p>求多个数相乘的约数个数，如6的约数个数是4：1，2，3，6。解决方案是考虑将约数分解为质因数指数幂的乘积形式。<br>如$ 6 = 2^1*3^1 $，考虑每个质因数可以选取不同个数和其他质因数配对，假设每个质因数的个数分别为：$a_1,a_2,a_3,\cdots,a_i$，则总的约数个数为$(a_1+1)(a_2+1)(a_3+1)\cdots(a_i+1)$</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>, MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;primes;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>) primes[i]++,x/=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>) primes[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;<span class="comment">//注意这里要long long，不然取模之前可能会溢出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime:primes) res=((res%MOD)*(prime.second+<span class="number">1</span>%MOD))%MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find factors</title>
      <link href="/2020/05/10/Algorithm/%E6%95%B0%E8%AE%BA/Find%20factors/"/>
      <url>/2020/05/10/Algorithm/%E6%95%B0%E8%AE%BA/Find%20factors/</url>
      
        <content type="html"><![CDATA[<p>试除法求约数，时间复杂度nsqrt(a)，和判断素数有点类似</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vi;</span><br><span class="line">    vi.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>) &#123;</span><br><span class="line">            vi.push_back(i);</span><br><span class="line">            vi.push_back(x/i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vi.push_back(x);</span><br><span class="line">    vi.erase(unique(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>()),vi.<span class="built_in">end</span>());</span><br><span class="line">    sort(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vi)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        factor(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prime-factor prime</title>
      <link href="/2020/05/09/Algorithm/%E6%95%B0%E8%AE%BA/Prime-factor%20prime/"/>
      <url>/2020/05/09/Algorithm/%E6%95%B0%E8%AE%BA/Prime-factor%20prime/</url>
      
        <content type="html"><![CDATA[<p>素数筛，有三种筛法：朴素，埃氏，线性。复杂度分别为 nlogn, nloglogn, n</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N],cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//朴素筛法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_arr</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;=n;j+=i)&#123;</span><br><span class="line">            st[j] = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//埃氏筛法，只用素数去筛合数，但还是会重复筛数，比如 6=2*3=3*2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_arr</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;=n;j+=i)&#123;</span><br><span class="line">            st[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性筛法，每次只用最小质因子去筛合数，每个合数只被筛了一次，避免了埃氏算法重复筛数的问题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_arr</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;prime[j]&lt;=n/i;j++)&#123;</span><br><span class="line">            st[prime[j]*i] = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//保证prime[j]是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    prime_arr(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List prime factor</title>
      <link href="/2020/05/09/Algorithm/%E6%95%B0%E8%AE%BA/Prime%20factor/"/>
      <url>/2020/05/09/Algorithm/%E6%95%B0%E8%AE%BA/Prime%20factor/</url>
      
        <content type="html"><![CDATA[<p>枚举质因数，O(sqrt(n))，最好O(log(n))</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((x%i)==<span class="number">0</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            x/=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,x,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        factor(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Check prime</title>
      <link href="/2020/05/09/Algorithm/%E6%95%B0%E8%AE%BA/Check%20prime/"/>
      <url>/2020/05/09/Algorithm/%E6%95%B0%E8%AE%BA/Check%20prime/</url>
      
        <content type="html"><![CDATA[<p>常规的判断质数，以前都用的i*i&lt;=n, 可以优化为i &lt;= n/i，避免溢出</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(isPrime(x)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum bipartite graph matching</title>
      <link href="/2020/05/09/Algorithm/%E4%BA%8C%E9%83%A8%E5%9B%BE/Maximum%20bipartite%20graph%20matching/"/>
      <url>/2020/05/09/Algorithm/%E4%BA%8C%E9%83%A8%E5%9B%BE/Maximum%20bipartite%20graph%20matching/</url>
      
        <content type="html"><![CDATA[<p>用到了匈牙利匹配算法，这个算法的大体流程就是为左半部的点分配右半部的点，如果产生冲突，则将冲突产生点之前的点进行重新分配，直至没有冲突为止。这个算法还可以用于多目标跟踪的匹配（毕设的时候竟然没了解这个）</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    用链表花的时间和直接用邻接矩阵花的时间差不多，这里开两个数组，整型数组记录在左边某点访问时，右边点的状态（避免产生冲突时发生死循环），布尔数组是记录访问状态和匹配到的点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n1,n2,m;</span><br><span class="line"><span class="keyword">int</span> e[M],nxt[M],h[N],idx;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[idx] = v;</span><br><span class="line">    nxt[idx] = h[u];</span><br><span class="line">    h[u] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[j] || <span class="built_in">find</span>(match[j]))&#123;</span><br><span class="line">                match[j] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n1,&amp;n2,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add_edge(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二部图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coloring bipartite graph</title>
      <link href="/2020/05/09/Algorithm/%E4%BA%8C%E9%83%A8%E5%9B%BE/Coloring%20bipartite%20graph/"/>
      <url>/2020/05/09/Algorithm/%E4%BA%8C%E9%83%A8%E5%9B%BE/Coloring%20bipartite%20graph/</url>
      
        <content type="html"><![CDATA[<p>染色法判定二分图，和图的联通性有一些相通之处，用dfs解决，如果相连节点染色出现冲突，则说明无法划分为二分图</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>; <span class="comment">//注意由于是无向图，实际边数是最大输入边数的两倍</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> e[M], nxt[M], h[M],idx;</span><br><span class="line"><span class="keyword">int</span> color[N];  <span class="comment">//color 用int数组表示，既可以记录是否访问过该节点，也可以表示该节点染的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[idx] = v;</span><br><span class="line">    nxt[idx] = h[u];</span><br><span class="line">    h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; u &lt;&lt; " " &lt;&lt; c &lt;&lt;endl;</span></span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!color[j]) dfs(j,<span class="number">3</span>-c);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[j]==c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add_edge(u,v);</span><br><span class="line">        add_edge(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i,<span class="number">1</span>))&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bipartite graph </tag>
            
            <tag> coloring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal</title>
      <link href="/2020/05/09/Algorithm/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/Kruskal/"/>
      <url>/2020/05/09/Algorithm/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/Kruskal/</url>
      
        <content type="html"><![CDATA[<p>Kruskal算法，以并查集为算法的基础，思想和prim也有些相似，先对边权排序（升序），每次将不在集合中的点加入集合，直到集合中点达到n (或看作边数达到n-1)，时间复杂度：mlogm</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>,M=<span class="number">200010</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, par[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="comment">//这里不用比较函数，直接在边里写个operator&lt;的函数也可以</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Edge&amp; e1, <span class="keyword">const</span> Edge&amp; e2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.w &lt; e2.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPar</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> par[u] = par[u] == u?u:findPar(par[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        edge[i] = &#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edge,edge+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        par[i] = i;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>,cnt=<span class="number">1</span>; <span class="comment">//注意这里cnt初始化为1，因为第一个根节点实际没有进行计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = edge[i].u, b = edge[i].v;</span><br><span class="line">        a = findPar(a), b = findPar(b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b) &#123;</span><br><span class="line">            par[b] = a;</span><br><span class="line">            res+=edge[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prim</title>
      <link href="/2020/05/08/Algorithm/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/Prim/"/>
      <url>/2020/05/08/Algorithm/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/Prim/</url>
      
        <content type="html"><![CDATA[<p>Prim算法，可以看作把dij用于生成树，只是这里的权重是点到生成的集合的距离，如果能更新n次，则n个点都成功生成，否则则失败。需要注意第一个点的处理。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist[N],res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist,inf,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;  <span class="comment">//第一个点进去时，res没有更新因此需要循环n次</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (!~t||dist[t]&gt;dist[j])) &#123;   <span class="comment">//找到离当前集合最小值</span></span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; t &lt;&lt; " " &lt;&lt; dist[t] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t]==inf) <span class="keyword">return</span> -inf; </span><br><span class="line">        <span class="keyword">if</span>(i) res+=dist[t];</span><br><span class="line">        st[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j],g[t][j]);  <span class="comment">//用 t 去更新其他点的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g,inf,<span class="keyword">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) g[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        g[u][v] = g[v][u] = <span class="built_in">min</span>(g[u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = prim();</span><br><span class="line">    <span class="keyword">if</span>(t==-inf) <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Floyd</title>
      <link href="/2020/05/08/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/Floyd/"/>
      <url>/2020/05/08/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/Floyd/</url>
      
        <content type="html"><![CDATA[<p>Floyd 用于求多源最短路，即可算任意两点间的最短路，复杂度O(n^3)。其代码量比较小，主要的思想就是在计算两点i，j间的最短路时，考虑经过中间点k和不经过中间点k的情况，其思想和dp类型。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dist[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(dist,inf,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dist[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        dist[u][v] = <span class="built_in">min</span>(dist[u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(dist[l][r]&gt;inf/<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dist[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Check negative circle</title>
      <link href="/2020/05/08/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/checkNegativeCircle/"/>
      <url>/2020/05/08/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/checkNegativeCircle/</url>
      
        <content type="html"><![CDATA[<p>判断负环，这里用了两种方法，spfa和bellman-ford，实际bellman要快些，bellman复杂度为O(nm)。</p><a id="more"></a><h3 id="spfa-判断负环"><a href="#spfa-判断负环" class="headerlink" title="spfa 判断负环"></a>spfa 判断负环</h3><p>spfa这里要注意需要把所有元素都入队，如果手写队列，要用双端队列来写，因为元素会重复入队，导致实际存储大于N</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> e[N],nxt[N],h[N],w[N],idx,cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> wei)</span> </span>&#123;</span><br><span class="line">    e[idx] = v;</span><br><span class="line">    w[idx] = wei;</span><br><span class="line">    nxt[idx]= h[u];</span><br><span class="line">    h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist[N];</span><br><span class="line">    <span class="comment">// dist[1] = 0;</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dist[i] = <span class="number">0</span>;</span><br><span class="line">        q.push(i);</span><br><span class="line">        st[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            st[t] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]) &#123;</span><br><span class="line">                    dist[j] = dist[t]+w[i];</span><br><span class="line">                    cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!st[j]) st[j] = <span class="number">1</span>,q.push(j);</span><br><span class="line">                    <span class="keyword">if</span>(cnt[j] &gt; n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,wei;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;wei);</span><br><span class="line">        add_edge(u,v,wei);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(spfa()) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellman-ford-判断负环"><a href="#bellman-ford-判断负环" class="headerlink" title="bellman-ford 判断负环"></a>bellman-ford 判断负环</h3><p>用结构体比用数组链要快些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dist[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> update = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[edge[k].u]&gt;dist[edge[k].v]+edge[k].w)&#123;</span><br><span class="line">                    dist[edge[k].u] = dist[edge[k].v]+edge[k].w;</span><br><span class="line">                    update = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==n &amp;&amp; update)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,wei;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;wei);</span><br><span class="line">        edge[i] = &#123;u,v,wei&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bellman()) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPFA Algorithm</title>
      <link href="/2020/05/08/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/SPFA/"/>
      <url>/2020/05/08/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/SPFA/</url>
      
        <content type="html"><![CDATA[<p>像dijksra的优化bellman，与dij的区别是它可以重新入队，而对dij而言，已经出队的元素是不会再入队了。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> e[N],nxt[N],h[N],w[N],idx;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> we)</span></span>&#123;</span><br><span class="line">    e[idx] = v;</span><br><span class="line">    w[idx] = we;</span><br><span class="line">    nxt[idx] = h[u];</span><br><span class="line">    h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist[N];</span><br><span class="line">    <span class="built_in">memset</span>(dist,inf,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]) &#123;</span><br><span class="line">                dist[j] = dist[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.push(j);st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==inf) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,we;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;we);</span><br><span class="line">        add_edge(u,v,we);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = spfa();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bellman-Ford Algorithm</title>
      <link href="/2020/05/08/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/2020-5-8-Bellman/"/>
      <url>/2020/05/08/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/2020-5-8-Bellman/</url>
      
        <content type="html"><![CDATA[<p>从核心的更新步骤来看，bellman ford与dijkstra有很强的相似性，但bellman对一个点可以进行多次更新，而dijkstra在到达该点后，如已经确定为当前的最短路，则不会再更新，而当存在负权边或负环时，dij算法失效。<br>但若不存在负权边，dij比bellman高效很多。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist[N],back[N];</span><br><span class="line">    <span class="built_in">memset</span>(dist,inf,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">//bellman 第一重循环可以设置最多经过几条边</span></span><br><span class="line">          <span class="built_in">memcpy</span>(back,dist,<span class="keyword">sizeof</span> dist); <span class="comment">//back的目的是避免进行串联更新</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;m;d++) &#123;</span><br><span class="line">              <span class="keyword">auto</span> e = edge[d];</span><br><span class="line">              dist[e.v] = <span class="built_in">min</span>(dist[e.v],back[e.u]+e.w);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]&gt;inf/<span class="number">2</span>) <span class="keyword">return</span> -inf;</span><br><span class="line">    <span class="keyword">else</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        edge[i] = &#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = bell();</span><br><span class="line">    <span class="keyword">if</span>(t==-inf)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Preprocess IMDB dataset</title>
      <link href="/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/"/>
      <url>/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/</url>
      
        <content type="html"><![CDATA[<p>This article talks about how to process heterogeneous dataset IMDB coarsely. And the data is used to train the heterogeneous graph.</p><a id="more"></a><h2 id="Data-preprocessing"><a href="#Data-preprocessing" class="headerlink" title="Data preprocessing"></a>Data preprocessing</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p><strong>IMDB</strong></p><p><img src="/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/image-20200402100748487.png" alt="image-20200402100748487"></p><ol><li><p>Nodes type</p><table><thead><tr><th align="center">Node Type</th><th align="center">Number</th></tr></thead><tbody><tr><td align="center">Movie</td><td align="center">4218</td></tr><tr><td align="center">Actor</td><td align="center">5233</td></tr><tr><td align="center">Director</td><td align="center">2053</td></tr></tbody></table></li></ol><ol start="2"><li><p>Edge type</p><table><thead><tr><th align="center">Edge Type</th><th align="center">Number</th></tr></thead><tbody><tr><td align="center">Movie — Actor</td><td align="center">12654</td></tr><tr><td align="center">Movie — Director</td><td align="center">4218</td></tr></tbody></table></li></ol><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><ol><li><p>Node feature</p><blockquote><p>Movie: </p><ul><li><p>Description: plot of the movie</p><p>eg.: avatar|future|marine|native|paraplegic</p><p>Use Bag of Words to convert the description to vector:  2109 words (min_freq = 3)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(&#39;zoo&#39;, 2108),</span><br><span class="line">(&#39;zombie&#39;, 2107),</span><br><span class="line">(&#39;younger&#39;, 2106),</span><br><span class="line">(&#39;young&#39;, 2105),</span><br><span class="line">(&#39;you&#39;, 2104),</span><br><span class="line">(&#39;york&#39;, 2103),</span><br><span class="line">(&#39;year&#39;, 2102),</span><br><span class="line">(&#39;yard&#39;, 2101),</span><br><span class="line">(&#39;yakuza&#39;, 2100),</span><br><span class="line">(&#39;yacht&#39;, 2099),</span><br><span class="line">(&#39;wyoming&#39;, 2098),</span><br><span class="line">(&#39;wrongful&#39;, 2097),</span><br><span class="line">(&#39;wrong&#39;, 2096),</span><br><span class="line">(&#39;written&#39;, 2095),</span><br><span class="line">(&#39;writing&#39;, 2094),</span><br><span class="line">(&#39;writer&#39;, 2093),</span><br><span class="line">(&#39;wrestling&#39;, 2092),</span><br><span class="line">(&#39;wrestler&#39;, 2091),</span><br><span class="line">(&#39;world&#39;, 2090),</span><br></pre></td></tr></table></figure></li><li><p>Label:</p><p>Choose three labels of highest frequency:</p><pre><code>*  Drama: 1809* Comedy: 1804* Thriller: 605</code></pre></li></ul><p>Actor/ Director:</p><ul><li><p>Mean of the Movie features the actor participated or the director directed</p><p>Feature of Director  = mean(feature of movie his/her directed)</p><p>Feature of Actor  = mean(feature of movie his/her participated)</p></li></ul></blockquote></li><li><p>Metapath matrix (Coarse)</p><blockquote><p>Movie — Actor — Movie</p><p>(4218*4218)</p><p>Movie — Director — Movie</p><p>(4218*4218)</p></blockquote></li></ol><h2 id="Baseline-Model-train"><a href="#Baseline-Model-train" class="headerlink" title="Baseline Model train"></a>Baseline Model train</h2><p>Train, validation and test split</p><table><thead><tr><th align="center">Train</th><th align="center">20%</th></tr></thead><tbody><tr><td align="center">Test</td><td align="center">70%</td></tr><tr><td align="center">Validation</td><td align="center">10%</td></tr></tbody></table><h3 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h3><h4 id="Test-result"><a href="#Test-result" class="headerlink" title="Test result"></a>Test result</h4><p>Test Loss 2.5578 | Test Accuracy 0.4887 | Test Micro F1 score 0.4887 | Test Macro F1 score 0.4150</p><h3 id="GAT"><a href="#GAT" class="headerlink" title="GAT"></a>GAT</h3><h4 id="Test-result-1"><a href="#Test-result-1" class="headerlink" title="Test result"></a>Test result</h4><p>Test Loss 4.9244 | Test Accuracy 0.3681 | Test Micro F1 score 0.4341 | Test Macro F1 score 0.4087</p><h3 id="HAN"><a href="#HAN" class="headerlink" title="HAN"></a>HAN</h3><h4 id="Test-result-2"><a href="#Test-result-2" class="headerlink" title="Test result"></a>Test result</h4><p>Test loss 0.9575 | Test Accuracy 0.5510 | Test Micro f1 0.5510 | Test Macro f1 0.3987</p><h3 id="MNGat-meta-neighbor-aggregated-graph-attention-network"><a href="#MNGat-meta-neighbor-aggregated-graph-attention-network" class="headerlink" title="MNGat (meta-neighbor aggregated graph attention network)"></a>MNGat (meta-neighbor aggregated graph attention network)</h3><p>Test Loss 1.0032 | Test Accuracy 0.6482 | Test Micro F1 score 0.6482 | Test Macro F1 score 0.5517</p><h2 id="Comparison-between-these-models"><a href="#Comparison-between-these-models" class="headerlink" title="Comparison between these models"></a>Comparison between these models</h2><h3 id="Train-accuracy"><a href="#Train-accuracy" class="headerlink" title="Train accuracy"></a>Train accuracy</h3><img src="/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/trac.jpg" alt="image-20200402003111384" style="zoom:150%;"><h4 id="Validation-accuracy"><a href="#Validation-accuracy" class="headerlink" title="Validation accuracy"></a>Validation accuracy</h4><img src="/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/valac.jpg" alt="image-20200402003111384" style="zoom:150%;"><h4 id="Train-microF1-Score"><a href="#Train-microF1-Score" class="headerlink" title="Train microF1 Score"></a>Train microF1 Score</h4><img src="/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/trm1.jpg" alt="image-20200402003111384" style="zoom:150%;"><h4 id="Validation-microF1-Score"><a href="#Validation-microF1-Score" class="headerlink" title="Validation microF1 Score"></a>Validation microF1 Score</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/valm1.jpg" alt="image-20200402003111384" style="zoom:150%;"></h4><h4 id="Train-Loss"><a href="#Train-Loss" class="headerlink" title="Train Loss"></a>Train Loss</h4><img src="/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/trloss.jpg" alt="image-20200402003111384" style="zoom:150%;"><h4 id="Validation-Loss"><a href="#Validation-Loss" class="headerlink" title="Validation Loss"></a>Validation Loss</h4><h4 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/valloss.jpg" alt="image-20200402003111384" style="zoom:150%;"></h4><h3 id="Proposed-Model"><a href="#Proposed-Model" class="headerlink" title="Proposed Model"></a>Proposed Model</h3><ol><li><p>Node aggregation</p><blockquote><p>Consider different types of neighborhoods and aggregate features</p><p>Consider metapath guided destination neighborhoods </p></blockquote></li><li><p>Semantic aggregation</p><p>Attention mechanism</p></li></ol><p><img src="/2020/04/01/Algorithm/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/2020-4-10-PreprocessingIMDB/image-20200402003628394.png" alt="image-20200402003628394"></p>]]></content>
      
      
      <categories>
          
          <category> Heterogeneous graph neural network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> metapath </tag>
            
            <tag> data preprocessing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
